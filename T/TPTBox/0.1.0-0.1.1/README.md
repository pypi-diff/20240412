# Comparing `tmp/tptbox-0.1.0-py3-none-any.whl.zip` & `tmp/tptbox-0.1.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,44 +1,46 @@
-Zip file size: 1140001 bytes, number of entries: 58
+Zip file size: 1141866 bytes, number of entries: 60
 -rwxr-xr-x  2.0 unx     1119 b- defN 80-Jan-01 00:00 TPTBox/__init__.py
 -rwxr-xr-x  2.0 unx      619 b- defN 80-Jan-01 00:00 TPTBox/core/__init__.py
 -rwxr-xr-x  2.0 unx     3972 b- defN 80-Jan-01 00:00 TPTBox/core/bids_constants.py
 -rwxr-xr-x  2.0 unx    55801 b- defN 80-Jan-01 00:00 TPTBox/core/bids_files.py
 -rwxr-xr-x  2.0 unx    64166 b- defN 80-Jan-01 00:00 TPTBox/core/nii_wrapper.py
 -rwxr-xr-x  2.0 unx     9151 b- defN 80-Jan-01 00:00 TPTBox/core/nii_wrapper_math.py
 -rwxr-xr-x  2.0 unx    37507 b- defN 80-Jan-01 00:00 TPTBox/core/np_utils.py
--rwxr-xr-x  2.0 unx    69391 b- defN 80-Jan-01 00:00 TPTBox/core/poi.py
--rwxr-xr-x  2.0 unx    28688 b- defN 80-Jan-01 00:00 TPTBox/core/poi_abstract.py
+-rwxr-xr-x  2.0 unx    69550 b- defN 80-Jan-01 00:00 TPTBox/core/poi.py
+-rwxr-xr-x  2.0 unx    28761 b- defN 80-Jan-01 00:00 TPTBox/core/poi_abstract.py
 -rwxr-xr-x  2.0 unx     2907 b- defN 80-Jan-01 00:00 TPTBox/core/poi_global.py
 -rwxr-xr-x  2.0 unx    18197 b- defN 80-Jan-01 00:00 TPTBox/core/sitk_utils.py
 -rwxr-xr-x  2.0 unx     7861 b- defN 80-Jan-01 00:00 TPTBox/core/vert_constants.py
--rwxr-xr-x  2.0 unx    45577 b- defN 80-Jan-01 00:00 TPTBox/core/vertebra_pois_non_centroids.py
+-rwxr-xr-x  2.0 unx    47636 b- defN 80-Jan-01 00:00 TPTBox/core/vertebra_pois_non_centroids.py
 -rwxr-xr-x  2.0 unx      207 b- defN 80-Jan-01 00:00 TPTBox/docker/__init__.py
 -rwxr-xr-x  2.0 unx    36551 b- defN 80-Jan-01 00:00 TPTBox/docker/docker.py
 -rwxr-xr-x  2.0 unx     1392 b- defN 80-Jan-01 00:00 TPTBox/docker/docker_run.py
 -rwxr-xr-x  2.0 unx      165 b- defN 80-Jan-01 00:00 TPTBox/logger/__init__.py
 -rwxr-xr-x  2.0 unx     5063 b- defN 80-Jan-01 00:00 TPTBox/logger/log_constants.py
--rwxr-xr-x  2.0 unx    15027 b- defN 80-Jan-01 00:00 TPTBox/logger/log_file.py
+-rwxr-xr-x  2.0 unx    15482 b- defN 80-Jan-01 00:00 TPTBox/logger/log_file.py
 -rw-r--r--  2.0 unx     4836 b- defN 80-Jan-01 00:00 TPTBox/mesh3D/mesh.py
 -rwxr-xr-x  2.0 unx     4633 b- defN 80-Jan-01 00:00 TPTBox/mesh3D/mesh_colors.py
 -rwxr-xr-x  2.0 unx      418 b- defN 80-Jan-01 00:00 TPTBox/registration/__init__.py
 -rwxr-xr-x  2.0 unx    13413 b- defN 80-Jan-01 00:00 TPTBox/registration/_deepali/test.py
 -rwxr-xr-x  2.0 unx     3715 b- defN 80-Jan-01 00:00 TPTBox/registration/ridged_intensity/register.py
 -rwxr-xr-x  2.0 unx      144 b- defN 80-Jan-01 00:00 TPTBox/registration/ridged_points/__init__.py
 -rwxr-xr-x  2.0 unx    11219 b- defN 80-Jan-01 00:00 TPTBox/registration/ridged_points/point_registration.py
 -rwxr-xr-x  2.0 unx     7039 b- defN 80-Jan-01 00:00 TPTBox/registration/script_ax2sag.py
 -rwxr-xr-x  2.0 unx    13839 b- defN 80-Jan-01 00:00 TPTBox/registration/script_ax2sag_v2.py
 -rwxr-xr-x  2.0 unx     8053 b- defN 80-Jan-01 00:00 TPTBox/spine/POI_plotter.py
 -rw-r--r--  2.0 unx      835 b- defN 80-Jan-01 00:00 TPTBox/spine/mesh3D/vert_mesh_colors.py
+-rw-r--r--  2.0 unx       44 b- defN 80-Jan-01 00:00 TPTBox/spine/segmentation/__init__.py
+-rw-r--r--  2.0 unx     2125 b- defN 80-Jan-01 00:00 TPTBox/spine/segmentation/spineps.py
 -rwxr-xr-x  2.0 unx      221 b- defN 80-Jan-01 00:00 TPTBox/spine/snapshot2D/__init__.py
 -rwxr-xr-x  2.0 unx    33768 b- defN 80-Jan-01 00:00 TPTBox/spine/snapshot2D/snapshot_modular.py
 -rwxr-xr-x  2.0 unx    15619 b- defN 80-Jan-01 00:00 TPTBox/spine/snapshot2D/snapshot_templates.py
 -rwxr-xr-x  2.0 unx     2156 b- defN 80-Jan-01 00:00 TPTBox/spine/spinal_cord_segmentation/__count_segmented.py
 -rwxr-xr-x  2.0 unx        1 b- defN 80-Jan-01 00:00 TPTBox/spine/spinal_cord_segmentation/__init__.py
--rwxr-xr-x  2.0 unx    19735 b- defN 80-Jan-01 00:00 TPTBox/spine/spinal_cord_segmentation/seg_spinalcordtoolbox.py
+-rwxr-xr-x  2.0 unx    20055 b- defN 80-Jan-01 00:00 TPTBox/spine/spinal_cord_segmentation/seg_spinalcordtoolbox.py
 -rw-r--r--  2.0 unx     2256 b- defN 80-Jan-01 00:00 TPTBox/stitching/README.md
 -rwxr-xr-x  2.0 unx       86 b- defN 80-Jan-01 00:00 TPTBox/stitching/__init__.py
 -rwxr-xr-x  2.0 unx    11308 b- defN 80-Jan-01 00:00 TPTBox/stitching/__stitching_reg.py
 -rwxr-xr-x  2.0 unx    10048 b- defN 80-Jan-01 00:00 TPTBox/stitching/__stitching_vertical.py
 -rw-r--r--  2.0 unx   326043 b- defN 80-Jan-01 00:00 TPTBox/stitching/stitching.jpg
 -rwxr-xr-x  2.0 unx    22293 b- defN 80-Jan-01 00:00 TPTBox/stitching/stitching.py
 -rwxr-xr-x  2.0 unx     4427 b- defN 80-Jan-01 00:00 TPTBox/stitching/stitching_tools.py
@@ -49,12 +51,12 @@
 -rw-r--r--  2.0 unx   259999 b- defN 80-Jan-01 00:00 TPTBox/tests/sample_mri/sub-mri_label-6_T2w.nii.gz
 -rw-r--r--  2.0 unx    12846 b- defN 80-Jan-01 00:00 TPTBox/tests/sample_mri/sub-mri_seg-subreg_label-6_msk.nii.gz
 -rw-r--r--  2.0 unx    12144 b- defN 80-Jan-01 00:00 TPTBox/tests/sample_mri/sub-mri_seg-vert_label-6_msk.nii.gz
 -rwxr-xr-x  2.0 unx     1756 b- defN 80-Jan-01 00:00 TPTBox/tests/speedtest.py
 -rw-r--r--  2.0 unx     2871 b- defN 80-Jan-01 00:00 TPTBox/tests/speedtest_cc3d.py
 -rw-r--r--  2.0 unx     1045 b- defN 80-Jan-01 00:00 TPTBox/tests/speedtest_morphological.py
 -rw-r--r--  2.0 unx    11959 b- defN 80-Jan-01 00:00 TPTBox/tests/test_utils.py
--rw-r--r--  2.0 unx    34523 b- defN 80-Jan-01 00:00 tptbox-0.1.0.dist-info/LICENSE
--rw-r--r--  2.0 unx     4337 b- defN 80-Jan-01 00:00 tptbox-0.1.0.dist-info/METADATA
--rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 tptbox-0.1.0.dist-info/WHEEL
-?rw-r--r--  2.0 unx     5279 b- defN 16-Jan-01 00:00 tptbox-0.1.0.dist-info/RECORD
-58 files, 1651330 bytes uncompressed, 1131543 bytes compressed:  31.5%
+-rw-r--r--  2.0 unx    34523 b- defN 80-Jan-01 00:00 tptbox-0.1.1.dist-info/LICENSE
+-rw-r--r--  2.0 unx     4337 b- defN 80-Jan-01 00:00 tptbox-0.1.1.dist-info/METADATA
+-rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 tptbox-0.1.1.dist-info/WHEEL
+?rw-r--r--  2.0 unx     5464 b- defN 16-Jan-01 00:00 tptbox-0.1.1.dist-info/RECORD
+60 files, 1656750 bytes uncompressed, 1133110 bytes compressed:  31.6%
```

## zipnote {}

```diff
@@ -84,14 +84,20 @@
 
 Filename: TPTBox/spine/POI_plotter.py
 Comment: 
 
 Filename: TPTBox/spine/mesh3D/vert_mesh_colors.py
 Comment: 
 
+Filename: TPTBox/spine/segmentation/__init__.py
+Comment: 
+
+Filename: TPTBox/spine/segmentation/spineps.py
+Comment: 
+
 Filename: TPTBox/spine/snapshot2D/__init__.py
 Comment: 
 
 Filename: TPTBox/spine/snapshot2D/snapshot_modular.py
 Comment: 
 
 Filename: TPTBox/spine/snapshot2D/snapshot_templates.py
@@ -156,20 +162,20 @@
 
 Filename: TPTBox/tests/speedtest_morphological.py
 Comment: 
 
 Filename: TPTBox/tests/test_utils.py
 Comment: 
 
-Filename: tptbox-0.1.0.dist-info/LICENSE
+Filename: tptbox-0.1.1.dist-info/LICENSE
 Comment: 
 
-Filename: tptbox-0.1.0.dist-info/METADATA
+Filename: tptbox-0.1.1.dist-info/METADATA
 Comment: 
 
-Filename: tptbox-0.1.0.dist-info/WHEEL
+Filename: tptbox-0.1.1.dist-info/WHEEL
 Comment: 
 
-Filename: tptbox-0.1.0.dist-info/RECORD
+Filename: tptbox-0.1.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## TPTBox/core/poi.py

```diff
@@ -120,14 +120,15 @@
     orientation: Ax_Codes = ("R", "A", "S")
     zoom: None | Zooms = field(init=True, default=None)  # type: ignore
     shape: Triple | None = field(default=None, repr=True, compare=False)
     rotation: Rotation | None = field(default=None, repr=False, compare=False)
     origin: Coordinate | None = None
     # internal
     _zoom: None | Zooms = field(init=False, default=None, repr=False, compare=False)
+    _vert_orientation_pir = {}  # Elusive; will not be saved; will not be copied. For Buffering results  # noqa: RUF012
 
     @property
     def shape_int(self):
         assert self.shape is not None, "need shape information"
         return tuple(np.rint(list(self.shape)).astype(int))
 
     @property
@@ -1360,15 +1361,17 @@
 
     # print(subreg_id)
     subreg_id = add_prerequisites(int2loc(subreg_id if isinstance(subreg_id, Sequence) else [subreg_id]))  # type: ignore
     # print(subreg_id)
 
     log.print("Calc centroids from subregion id", subreg_id, vert_msk.shape, verbose=verbose)
     subreg_id_int = set(loc2int_list(subreg_id))
-    subreg_id_int_phase_1 = tuple(filter(lambda i: i < 60 and i not in [Location.Vertebra_Full.value], subreg_id_int))
+    subreg_id_int_phase_1 = tuple(
+        filter(lambda i: i < 60 and i not in [Location.Vertebra_Full.value, Location.Dens_axis.value], subreg_id_int)
+    )
     # Step 1 get all required locations, crop vert/subreg
     # Step 2 calc centroids
 
     # print("step 2", subreg_id_int)
     if len(subreg_id_int_phase_1) != 0:
         arr = vert_msk.get_array()
         arr[arr >= 100] = 0
@@ -1427,15 +1430,15 @@
     assert subreg_msk.shape == vert_arr.shape, "Shape miss-match" + str(subreg_msk.shape) + str(vert_arr.shape)
     vert_arr[subreg_arr >= 100] = 0
     subreg_arr[subreg_arr >= 100] = 0
 
     if extend_to is None:
         extend_to = POI({}, **vert_msk._extract_affine(), format=FORMAT_POI)
     if len(subreg_id_int) != 0:
-        # sprint("step 6", subreg_id_int)
+        # print("step 6", subreg_id_int)
         compute_non_centroid_pois(extend_to, int2loc(list(subreg_id_int)), vert_msk, subreg_msk, _vert_ids=_vert_ids, log=log)
     extend_to.apply_crop_reverse(crop, org_shape, inplace=True)
     return extend_to
 
 
 def calc_centroids_from_two_masks(
     lvl_1_msk: Image_Reference,
```

## TPTBox/core/poi_abstract.py

```diff
@@ -421,15 +421,15 @@
                 shape: first dimension to select a cord, second dimension to select all X/Y/Z
         """
         if isinstance(location, Location):
             location = location.value
         if location not in self.keys_subregion() or isinstance(location, (list, tuple)):
             raise ValueError(f"The location {location} is not computed in this POI class")
         # Extract subregion based on the provided location
-        poi = self.extract_subregion(location)
+        poi = self.extract_subregion(*location) if isinstance(location, Sequence) else self.extract_subregion(location)
 
         # If vertebra sorting is requested, perform it
         if vertebra:
             from TPTBox.core.poi import POI, VertebraCentroids
 
             if isinstance(poi, (VertebraCentroids, POI)):
                 poi = VertebraCentroids.from_pois(poi).sort()  # Set sorting
```

## TPTBox/core/vertebra_pois_non_centroids.py

```diff
@@ -71,15 +71,19 @@
                     if isinstance(j, Location):
                         prerequisite.add(j)
         self.prerequisite = prerequisite
         self.strategy = strategy
         all_poi_functions[target.value] = self
 
     def __call__(self, poi: POI, current_subreg: NII, vert_id: int, bb, log: Logger_Interface = _log):
-        return self.strategy(poi=poi, current_subreg=current_subreg, location=self.target, log=log, vert_id=vert_id, bb=bb, **self.args)
+        try:
+            return self.strategy(poi=poi, current_subreg=current_subreg, location=self.target, log=log, vert_id=vert_id, bb=bb, **self.args)
+        except Exception:
+            _log.print_error()
+            return None
 
 
 class Strategy_Pattern_Side_Effect(Strategy_Pattern):
     def __init__(self, target: Location, prerequisite: Location, **args) -> None:
         super().__init__(target, _strategy_side_effect, {prerequisite}, **args)
         pois_computed_by_side_effect[target.value] = prerequisite
 
@@ -126,34 +130,27 @@
     # check if label 50 is already computed in POI
     if poi is None or spline_subreg_point_id.value not in poi.keys_subregion():
         poi = calc_poi_from_subreg_vert(vert, subreg, extend_to=poi, subreg_id=spline_subreg_point_id)
     # compute Spline in ISO space
     poi_iso = poi.rescale().reorient()
     body_spline, body_spline_der = poi_iso.fit_spline(location=spline_subreg_point_id, vertebra=True)
     # Step 2 compute the back direction by spinal channel or arcus
-    subreg_ids = subreg.unique()
-    make_thicker = False
-    if Location.Spinal_Cord.value in subreg_ids:
-        intersection_target = [Location.Spinal_Cord, Location.Spinal_Canal]
-    else:
-        intersection_target = [Location.Spinal_Cord, Location.Spinal_Canal, Location.Spinosus_Process, Location.Arcus_Vertebrae]
-        make_thicker = True
+    intersection_target = [Location.Spinosus_Process, Location.Arcus_Vertebrae]
     # We compute everything in iso space
     subreg_iso = subreg.rescale().reorient()
 
     target_labels = subreg_iso.extract_label(intersection_target).get_array()
-    if make_thicker:
-        # for CT (<=> no spinal cord) we want to see more of the Spinosus_Process and Arcus_Vertebrae than we cut with the plane. Should reduce randomness.
-        # The ideal solution would be to make a projection onto the plane. Instead we fill values that have a vertical distanc of 10 mm up and down. This approximates the projection on to the plane.
-        # Without this we have the chance to miss most of the arcus and spinosus, witch leads to instability in the direction.
-        # TODO this will fail if the vertebra is not roughly aligned with S/I-direction
-        for _ in range(10):
-            target_labels[:, :-1] += target_labels[:, 1:]
-            target_labels[:, 1:] += target_labels[:, :-1]
-        target_labels = np.clip(target_labels, 0, 1)
+    # we want to see more of the Spinosus_Process and Arcus_Vertebrae than we cut with the plane. Should reduce randomness.
+    # The ideal solution would be to make a projection onto the plane. Instead we fill values that have a vertical distanc of 10 mm up and down. This approximates the projection on to the plane.
+    # Without this we have the chance to miss most of the arcus and spinosus, witch leads to instability in the direction.
+    # TODO this will fail if the vertebra is not roughly aligned with S/I-direction
+    for _ in range(15):
+        target_labels[:, :-1] += target_labels[:, 1:]
+        target_labels[:, 1:] += target_labels[:, :-1]
+    target_labels = np.clip(target_labels, 0, 1)
     out = target_labels * 0
     fill_back_nii = subreg_iso.copy() if do_fill_back else None
     fill_back = out.copy() if do_fill_back else None
     down_vector: dict[int, np.ndarray] = {}
     # Draw a plain with the up_vector an cut it with intersection_target
     for reg_label, _, cords in poi_iso.extract_subregion(source_subreg_point_id).items():
         # calculate_normal_vector
@@ -199,36 +196,37 @@
             cond = np.where(curr_slice != 0)
             x_slice[cond] = np.minimum(curr_slice[cond], x_slice[cond])
             fill_back[i] = x_slice
         arr = subreg_sar.set_array(fill_back).reorient(poi.orientation).rescale_(poi.zoom).get_array()
         fill_back_nii.set_array_(arr)
 
     ret = calc_centroids(subreg_iso.set_array(out), subreg_id=subreg_id, extend_to=poi_iso.copy(), inplace=True)
+    poi._vert_orientation_pir = {}
     if save_normals_in_info:
-        poi.info["vert_orientation_PIR"] = {}
+        poi.info["vert_orientation_PIR"] = poi._vert_orientation_pir
+
     # calc posterior vector and the crossproduct
     for vert_id, normal_down in down_vector.items():
         # get two points and compute the direction:
-        a = np.array(ret[vert_id : subreg_id.value])
-        b = np.array(ret[vert_id : source_subreg_point_id.value])
+        a = np.array(ret[vert_id : subreg_id.value]) - 1
+        b = np.array(ret[vert_id : source_subreg_point_id.value]) - 1
         normal_vector_post = a - b
         normal_vector_post = normal_vector_post / norm(normal_vector_post)
-        if save_normals_in_info:
-            poi.info["vert_orientation_PIR"][vert_id] = (normal_vector_post, normal_down, np.cross(normal_vector_post, normal_down))
+        poi._vert_orientation_pir[vert_id] = (normal_vector_post, normal_down, np.cross(normal_vector_post, normal_down))
 
         ### MAKE directions POIs ###
         # print(ret[vert_id, source_subreg_point_id], normal_vector_post)
-        ret[vert_id, Location.Vertebra_Direction_Posterior] = tuple(ret[vert_id, source_subreg_point_id] + normal_vector_post)
-        ret[vert_id, Location.Vertebra_Direction_Inferior] = tuple(ret[vert_id, source_subreg_point_id] + normal_down)
+        ret[vert_id, Location.Vertebra_Direction_Posterior] = tuple(ret[vert_id, source_subreg_point_id] + normal_vector_post * 10)
+        ret[vert_id, Location.Vertebra_Direction_Inferior] = tuple(ret[vert_id, source_subreg_point_id] + normal_down * 10)
         ret[vert_id, Location.Vertebra_Direction_Right] = tuple(
-            ret[vert_id:source_subreg_point_id] + np.cross(normal_vector_post, normal_down)
+            ret[vert_id:source_subreg_point_id] + np.cross(normal_vector_post, normal_down * 10)
         )
 
-    if make_thicker:
-        ret.remove_centroid(*ret.extract_subregion(subreg_id).keys())
+    # if make_thicker:
+    ret.remove_centroid(*ret.extract_subregion(subreg_id).keys())
     if spine_plot_path is not None:
         _make_spine_plot(ret, body_spline, vert, spine_plot_path)
 
     ret = ret.resample_from_to(poi)  # type: ignore
     return poi.join_right_(ret), fill_back_nii
 
 
@@ -325,26 +323,38 @@
     a = [_get_sub_array_by_direction(d, cords) for d in direction_]
     idx = np.argmax(sum(a))
     return pc[:, idx]
 
 
 def get_vert_direction_PIR(poi: POI, vert_id, do_norm=True) -> Vertebra_Orientation:
     """Retive the vertebra orientation from the POI. Must be computed by calc_orientation_of_vertebra_PIR first."""
-    center = np.array(poi[vert_id : Location.Vertebra_Corpus])
-    post = np.array(poi[vert_id : Location.Vertebra_Direction_Posterior])
-    down = np.array(poi[vert_id : Location.Vertebra_Direction_Inferior])
-    right = np.array(poi[vert_id : Location.Vertebra_Direction_Right])
+    if vert_id in poi._vert_orientation_pir:
+        return poi._vert_orientation_pir[vert_id]  # Elusive buffer of iso directions.
+    poi = (
+        poi.extract_subregion(
+            Location.Vertebra_Corpus,
+            Location.Vertebra_Direction_Posterior,
+            Location.Vertebra_Direction_Inferior,
+            Location.Vertebra_Direction_Right,
+        )
+        .rescale(verbose=False)
+        .reorient(verbose=False)
+    )
 
     def n(x):
-        if do_norm:
-            return x / norm(x)
-        else:
-            return x
+        return x / norm(x) if do_norm else x
 
-    return n(post - center), n(down - center), n(right - center)
+    for k in poi.keys_region():
+        center = np.array(poi[k : Location.Vertebra_Corpus])
+        post = np.array(poi[k : Location.Vertebra_Direction_Posterior])
+        down = np.array(poi[k : Location.Vertebra_Direction_Inferior])
+        right = np.array(poi[k : Location.Vertebra_Direction_Right])
+
+        poi._vert_orientation_pir[k] = n(post - center), n(down - center), n(right - center)
+    return poi._vert_orientation_pir[vert_id]
 
 
 def get_vert_direction_matrix(poi: POI, vert_id: int):
     P, I, R = get_vert_direction_PIR(poi, vert_id=vert_id)  # noqa: N806
     from_vert_orient = np.stack([P, I, R], axis=1)
     to_vert_orient = np.linalg.inv(from_vert_orient)
     return to_vert_orient, from_vert_orient
@@ -352,15 +362,15 @@
 
 def strategy_extreme_points(
     poi: POI,
     current_subreg: NII,
     location: Location,
     direction: Sequence[Directions] | Directions,
     vert_id: int,
-    subreg_id: Location,
+    subreg_id: Location | list[Location],
     bb,
     log=_log,
 ):
     """Strategy function to update extreme points of a point of interest based on direction.
 
     Args:
         poi (POI): The point of interest.
@@ -368,17 +378,18 @@
         location (Location): The location to update in the point of interest.
         direction (Union[Sequence[Directions], Directions]): Direction(s) to search for the extreme point.
         vert_id (int): The vertex ID.
         subreg_id (Location): The subregion ID.
         bb: The bounding box.
         log (Logger_Interface, optional): The logger interface. Defaults to _log.
     """
+
     region = current_subreg.extract_label(subreg_id)
     if region.sum() == 0:
-        log.print(f"reg={vert_id},subreg={subreg_id} is missing (extreme_points)", ltype=Log_Type.FAIL)
+        log.print(f"reg={vert_id},subreg={subreg_id} is missing (extreme_points); {current_subreg.unique()}", ltype=Log_Type.FAIL)
         return
     # extreme_point = get_extreme_point(poi, region, vert_id, bb, anti_point)
 
     extreme_point = get_extreme_point_by_vert_direction(poi, region, vert_id, direction)
     if extreme_point is None:
         return
     poi[vert_id, location.value] = tuple(a.start + b for a, b in zip(bb, extreme_point, strict=True))
@@ -605,22 +616,25 @@
     if compute_arcus_points:
         arcus = current_subreg.extract_label(Location.Arcus_Vertebrae).get_array()
         plane_arcus = arcus[plane_coords[:, :, 0], plane_coords[:, :, 1], plane_coords[:, :, 2]]
         for in_id, out_id in [
             (1, Location.Ligament_Attachment_Point_Flava_Superior_Median.value),
             (3, Location.Ligament_Attachment_Point_Flava_Inferior_Median.value),
         ]:
-            loc102 = out_points[in_id]
-            # Transform 3D Point in 2D point of plane
-            arr_poi = arcus.copy() * 0
-            arr_poi[loc102[0], loc102[1], loc102[2]] = 1
-            loc102 = np.concatenate(np.where(arr_poi[plane_coords[:, :, 0], plane_coords[:, :, 1], plane_coords[:, :, 2]]))
-            loc125 = get_nearest_neighbor(loc102, plane_arcus, 1)  # 41
-            cords = plane_coords[loc125[0], loc125[1], :]
-            poi[vert_id, out_id] = tuple(x + y.start for x, y in zip(cords, bb, strict=False))
+            try:
+                loc102 = out_points[in_id]
+                # Transform 3D Point in 2D point of plane
+                arr_poi = arcus.copy() * 0
+                arr_poi[loc102[0], loc102[1], loc102[2]] = 1
+                loc102 = np.concatenate(np.where(arr_poi[plane_coords[:, :, 0], plane_coords[:, :, 1], plane_coords[:, :, 2]]))
+                loc125 = get_nearest_neighbor(loc102, plane_arcus, 1)  # 41
+                cords = plane_coords[loc125[0], loc125[1], :]
+                poi[vert_id, out_id] = tuple(x + y.start for x, y in zip(cords, bb, strict=False))
+            except Exception:
+                print(vert_id, out_id, "missed its target. Skipped")
 
 
 def _compute_vert_corners_in_reference_frame(poi: POI, vert_id: int, plane_coords: np.ndarray, subregion: np.ndarray):
     to_reference_frame, _ = get_vert_direction_matrix(poi, vert_id)
     # plane_coords x,y,3
     pc = (
         plane_coords[subregion[plane_coords[:, :, 0], plane_coords[:, :, 1], plane_coords[:, :, 2]] != 0].swapaxes(-1, 0).reshape((3, -1))
@@ -669,14 +683,15 @@
 Strategy_Pattern(L.Muscle_Inserts_Spinosus_Process, strategy=S, subreg_id=L.Spinosus_Process, direction=("P","I"))  # 81
 Strategy_Pattern(L.Muscle_Inserts_Transverse_Process_Right, strategy=S, subreg_id=L.Costal_Process_Right, direction=("P","R"))  # 82
 Strategy_Pattern(L.Muscle_Inserts_Transverse_Process_Left, strategy=S, subreg_id=L.Costal_Process_Left, direction=("P","L"))  # 83
 Strategy_Pattern(L.Muscle_Inserts_Articulate_Process_Inferior_Left, strategy=S, subreg_id=L.Inferior_Articular_Left, direction=("I")) # 86
 Strategy_Pattern(L.Muscle_Inserts_Articulate_Process_Inferior_Right, strategy=S, subreg_id=L.Inferior_Articular_Right, direction=("I")) # 87
 Strategy_Pattern(L.Muscle_Inserts_Articulate_Process_Superior_Left, strategy=S, subreg_id=L.Superior_Articular_Left, direction=("S")) # 88
 Strategy_Pattern(L.Muscle_Inserts_Articulate_Process_Superior_Right, strategy=S, subreg_id=L.Superior_Articular_Right, direction=("S")) # 89
+#Strategy_Pattern(L.Vertebra_Disc_Post, strategy=S, subreg_id=L.Vertebra_Disc, direction=("P"))
 S = strategy_line_cast
 Strategy_Pattern(L.Muscle_Inserts_Vertebral_Body_Right, strategy=S, regions_loc =[L.Vertebra_Corpus, L.Vertebra_Corpus_border],
                  start_point = L.Vertebra_Corpus, normal_vector_points ="R" ) # 84
 Strategy_Pattern(L.Muscle_Inserts_Vertebral_Body_Left, strategy=S, regions_loc =[L.Vertebra_Corpus, L.Vertebra_Corpus_border],
                  start_point = L.Vertebra_Corpus, normal_vector_points ="L" ) # 85
 Strategy_Pattern(
     L.Ligament_Attachment_Point_Anterior_Longitudinal_Superior_Median,
@@ -723,58 +738,85 @@
 Strategy_Pattern_Side_Effect(L.Ligament_Attachment_Point_Anterior_Longitudinal_Inferior_Left,L.Ligament_Attachment_Point_Anterior_Longitudinal_Superior_Left)
 Strategy_Pattern_Side_Effect(L.Ligament_Attachment_Point_Posterior_Longitudinal_Inferior_Left,L.Ligament_Attachment_Point_Anterior_Longitudinal_Superior_Left)
 Strategy_Pattern_Side_Effect(L.Additional_Vertebral_Body_Middle_Superior_Left,L.Ligament_Attachment_Point_Anterior_Longitudinal_Superior_Left)
 Strategy_Pattern_Side_Effect(L.Additional_Vertebral_Body_Posterior_Central_Left,L.Ligament_Attachment_Point_Anterior_Longitudinal_Superior_Left)
 Strategy_Pattern_Side_Effect(L.Additional_Vertebral_Body_Middle_Inferior_Left,L.Ligament_Attachment_Point_Anterior_Longitudinal_Superior_Left)
 Strategy_Pattern_Side_Effect(L.Additional_Vertebral_Body_Anterior_Central_Left,L.Ligament_Attachment_Point_Anterior_Longitudinal_Superior_Left)
 
-Strategy_Computed_Before(L.Spinal_Canal_ivd_lvl,L.Vertebra_Disc,L.Vertebra_Corpus)
+Strategy_Computed_Before(L.Dens_axis,L.Vertebra_Direction_Inferior)
+Strategy_Computed_Before(L.Spinal_Canal_ivd_lvl,L.Vertebra_Disc,L.Vertebra_Corpus,L.Dens_axis)
+Strategy_Computed_Before(L.Spinal_Cord,L.Vertebra_Disc,L.Vertebra_Corpus,L.Dens_axis)
 Strategy_Computed_Before(L.Spinal_Canal,L.Vertebra_Corpus)
+
 # fmt: on
-def compute_non_centroid_pois(
+def compute_non_centroid_pois(  # noqa: C901
     poi: POI,
     locations: Sequence[Location] | Location,
     vert: NII,
     subreg: NII,
     _vert_ids: Sequence[int] | None = None,
     log: Logger_Interface = _log,
 ):
+    if _vert_ids is None:
+        _vert_ids = vert.unique()
+
     locations = list(locations) if isinstance(locations, Sequence) else [locations]
     ### STEP 1 Vert Direction###
     if Location.Vertebra_Direction_Inferior in locations:
-        log.print("Compute Vertebra directions", locations)
+        log.print("Compute Vertebra directions")
         ### Calc vertebra direction; We always need them, so we just compute them. ###
         sub_regions = poi.keys_subregion()
         if any(a.value not in sub_regions for a in vert_directions):
             poi, _ = calc_orientation_of_vertebra_PIR(poi, vert, subreg, do_fill_back=False, save_normals_in_info=False)
             for i in vert_directions:
                 if i in locations:
                     locations.remove(i)
 
     locations = [pois_computed_by_side_effect.get(l.value, l) for l in locations]
     locations = sorted(list(set(locations)), key=lambda x: x.value)  # type: ignore # noqa: C414
     log.print("Calc pois from subregion id", {l.name for l in locations})
+    ### DENSE###
+    if Location.Dens_axis in locations and 2 in _vert_ids and (2, Location.Dens_axis.value) not in poi:
+        a = subreg * vert.extract_label(2)
+        bb = a.compute_crop()
+        a = a.apply_crop(bb)
+        s = [Location.Vertebra_Corpus, Location.Vertebra_Corpus_border]
+        if a.sum() != 0:
+            strategy_extreme_points(poi, a, location=Location.Dens_axis, direction=["S", "P"], vert_id=2, subreg_id=s, bb=bb)
     ### STEP 2 (Other global non centroid poi; Spinal heights ###
+
     if Location.Spinal_Canal in locations:
         locations.remove(Location.Spinal_Canal)
         subregs_ids = subreg.unique()
-        _a = Location.Spinal_Canal.value in subregs_ids or Location.Spinal_Cord.value in subregs_ids
+        _a = Location.Spinal_Canal.value in subregs_ids or Location.Spinal_Canal.value in subregs_ids
         if _a and Location.Spinal_Canal.value not in poi.keys_subregion():
-            poi = calc_center_spinal_cord(poi, subreg)
+            poi = calc_center_spinal_cord(poi, subreg, add_dense=True)
+    if Location.Spinal_Cord in locations:
+        locations.remove(Location.Spinal_Cord)
+        subregs_ids = subreg.unique()
+        v = Location.Spinal_Cord.value
+        if (v in subregs_ids or Location.Spinal_Cord.value in subregs_ids) and v not in poi.keys_subregion():
+            poi = calc_center_spinal_cord(
+                poi,
+                subreg,
+                source_subreg_point_id=Location.Vertebra_Disc,
+                subreg_id=Location.Spinal_Cord,
+                add_dense=True,
+                intersection_target=[Location.Spinal_Cord],
+            )
+
     if Location.Spinal_Canal_ivd_lvl in locations:
         locations.remove(Location.Spinal_Canal_ivd_lvl)
         subregs_ids = subreg.unique()
         v = Location.Spinal_Canal_ivd_lvl.value
         if (v in subregs_ids or Location.Spinal_Cord.value in subregs_ids) and v not in poi.keys_subregion():
             poi = calc_center_spinal_cord(
-                poi, subreg, source_subreg_point_id=Location.Vertebra_Disc, subreg_id=Location.Spinal_Canal_ivd_lvl
+                poi, subreg, source_subreg_point_id=Location.Vertebra_Disc, subreg_id=Location.Spinal_Canal_ivd_lvl, add_dense=True
             )
 
-    if _vert_ids is None:
-        _vert_ids = vert.unique()
     # Step 3 Compute on individual Vertebras
     for vert_id in _vert_ids:
         if vert_id >= 39:
             continue
         current_vert = vert.extract_label(vert_id)
         bb = current_vert.compute_crop()
         current_vert.apply_crop_(bb)
@@ -797,19 +839,20 @@
             else:
                 raise NotImplementedError(location.value)
 
 
 def calc_center_spinal_cord(
     poi: POI,
     subreg: NII,
-    spline_subreg_point_id=Location.Vertebra_Corpus,
-    source_subreg_point_id=Location.Vertebra_Corpus,
+    spline_subreg_point_id: Location = Location.Vertebra_Corpus,
+    source_subreg_point_id: Location = Location.Vertebra_Corpus,
     subreg_id=Location.Spinal_Canal,
     intersection_target: list[Location] | None = None,
     _fill_inplace: NII | None = None,
+    add_dense=False,
 ) -> POI:
     """
     Calculate the center of the spinal cord within a specified region.
 
     Parameters:
     - poi (POI): Point of Interest object containing relevant data.
     - subreg (NII): Neuroimaging subregion data for analysis.
@@ -845,14 +888,17 @@
     """
     from TPTBox import calc_centroids
 
     if intersection_target is None:
         intersection_target = [Location.Spinal_Cord, Location.Spinal_Canal]
     assert _fill_inplace is None or subreg == _fill_inplace
     poi_iso = poi.rescale()
+    if add_dense and (2, Location.Dens_axis) in poi_iso:
+        poi_iso[1, spline_subreg_point_id] = poi_iso[2, Location.Dens_axis]
+        poi_iso[1, source_subreg_point_id] = poi_iso[2, Location.Dens_axis]
     subreg_iso = subreg.rescale()
     body_spline, body_spline_der = poi_iso.fit_spline(location=spline_subreg_point_id, vertebra=True)
     target_labels = subreg_iso.extract_label(intersection_target).get_array()
     out = target_labels * 0
     fill_back = out.copy() if _fill_inplace is not None else None
     for reg_label, _, cords in poi_iso.extract_subregion(source_subreg_point_id).items():
         # calculate_normal_vector
```

## TPTBox/logger/log_file.py

```diff
@@ -23,15 +23,15 @@
 
 indentation_level: int = 0
 
 
 class Logger_Interface(Protocol):
     """General Logger Interface"""
 
-    override_prefix: str | None = None
+    prefix: str | None = None
 
     def print(
         self,
         *text,
         end="\n",
         ltype=Log_Type.TEXT,
         verbose: bool | None = None,
@@ -91,15 +91,15 @@
 
     def _prefix_indentation_level(self) -> str:
         """Returns the indentation as processed string
 
         Returns:
             str: indentantion string
         """
-        global indentation_level
+        global indentation_level  # noqa: PLW0602
         string = ""
         if indentation_level == 0:
             return string
         string = " " + "-" * ((indentation_level * 3) - 2) + " "
         return string
 
     def _get_logger_prefix(self, ltype: Log_Type = Log_Type.TEXT):
@@ -108,16 +108,16 @@
         Args:
             type (Log_Type, optional): _description_. Defaults to Log_Type.TEXT.
 
         Returns:
             _type_: _description_
         """
         indent: str = self._prefix_indentation_level()
-        if self.override_prefix is not None:
-            return indent + f"[{self.override_prefix}]"
+        if self.prefix is not None:
+            return indent + f"[{self.prefix}]"
         return indent + type2bcolors[ltype][1]
 
     def _log(self, text: str, end: str = "\n", ltype=Log_Type.TEXT):
         ...
 
     def close(self):
         ...
@@ -162,43 +162,47 @@
 
     def __init__(
         self,
         path: Path | str,
         log_filename: str | dict[str, str],
         default_verbose: bool = False,
         log_arguments=None,
+        prefix: str | None = None,
     ):
         """
 
         Args:
             path: path to the folder that needs logging (usual dataset with raw/der in it)
             log_filename: the filename or the bids-conform key-value pairs as dict
             default_verbose: default verbose behavior of not specified in calls
             log_arguments: if set, will print the contents in a "run with arguments" section
+            prefix: if set, will use this string as prefix instead of the automatically chosen one based on log_type
         """
         path = Path(path)  # ensure pathlib object
         # Get Start time
         self.start_time = get_time()
         start_time_short = format_time_short(self.start_time)
 
+        self.prefix = prefix
+
         # Processes log_filename
         log_filename_processed = ""
         if isinstance(log_filename, dict):
             for k, v in log_filename.items():
                 log_filename_processed += k + "-" + v + "_"
         else:
             log_filename_processed = log_filename + "_"
         log_filename_full = start_time_short + "_" + log_filename_processed + "log.log"
 
         # Creates logs folder if not existent
         log_path = Path(path).joinpath("logs")
         if not Path.exists(log_path):
             Path.mkdir(log_path)
         # Open log file
-        self.f = open(log_path.joinpath(log_filename_full), "w")
+        self.f = open(log_path.joinpath(log_filename_full), "w")  # noqa: SIM115
         # calls close() if program terminates
         self._finalizer = weakref.finalize(self.f, self.close)
         self.default_verbose = default_verbose
         # Log file always start with their name and start log time
         self.print(log_filename_processed[:-1], verbose=False, ltype=Log_Type.LOG)
         self.print(f"Log started at: {start_time_short}\n", ltype=Log_Type.LOG)
 
@@ -215,27 +219,28 @@
 
     @classmethod
     def create_from_bids(
         cls,
         bids_file: BIDS_FILE,
         log_filename: str | dict[str, str],
         default_verbose: bool = False,
+        override_prefix: str | None = None,
     ):
         """Creates a logger object based on metadata from a BIDS_FILE
 
         Args:
             bids_file (BIDS_FILE): _description_
             log_filename (str | dict[str, str]): _description_
             default_verbose (bool, optional): _description_. Defaults to False.
 
         Returns:
             _type_: _description_
         """
         path = bids_file.dataset
-        return Logger(path, log_filename, default_verbose=default_verbose)
+        return Logger(path, log_filename, default_verbose=default_verbose, prefix=override_prefix)
 
     def _log(self, text: str, end: str = "\n", ltype=Log_Type.TEXT):  # noqa: ARG002
         self.f.write(str(text))
         self.f.write(end)
 
     def flush(self):
         self.f.flush()
@@ -282,16 +287,21 @@
 
 
 class No_Logger(Logger_Interface):
     """
     Does not create any logs, but instead verbose defaults to true, printing calls to the terminal
     """
 
-    def __init__(self, print_log_started: bool = False):
+    def __init__(
+        self,
+        print_log_started: bool = False,
+        prefix: str | None = None,
+    ):
         self.default_verbose = True
+        self.prefix = prefix
 
         if print_log_started:
             self.start_time = get_time()
             start_time_short = format_time_short(self.start_time)
             self.print(f"Log started at: {start_time_short}\n", ltype=Log_Type.LOG)
 
     def _log(self, text: str, end: str = "\n", ltype=Log_Type.TEXT):
@@ -341,16 +351,22 @@
 
 
 class String_Logger(Logger_Interface):
     """
     Logger that logs only to a string object "log_content".
     """
 
-    def __init__(self, default_verbose: bool = False, finalize: bool = True):
+    def __init__(
+        self,
+        default_verbose: bool = False,
+        finalize: bool = True,
+        prefix: str | None = None,
+    ):
         self.default_verbose = default_verbose
+        self.prefix = prefix
         self.log_content = ""
         self.log_content_colored = ""
         self.sub_loggers: list[String_Logger] = []
         self.start_time = get_time()
         self.head_logger: Logger_Interface | None = None
         if finalize:
             self._finalizer = weakref.finalize(self, self.close)
@@ -417,13 +433,13 @@
 
 def _set_indent(indent_change: int | bool):
     """Changes the indentation level
 
     Args:
         indent_change (int | bool): If bool, true/false == +1/-1, if int, sets to that int
     """
-    global indentation_level
+    global indentation_level  # noqa: PLW0603
     if isinstance(indent_change, bool):
         indentation_level = indentation_level + 1 if indent_change else max(0, indentation_level - 1)
     else:
         indentation_level = indent_change
     return indentation_level
```

## TPTBox/spine/spinal_cord_segmentation/seg_spinalcordtoolbox.py

```diff
@@ -6,16 +6,17 @@
 import subprocess
 import time
 from pathlib import Path
 
 import nibabel as nib
 import numpy as np
 
-from TPTBox import BIDS_FILE, NII, BIDS_Global_info, Subject_Container, to_nii_seg
+from TPTBox import BIDS_FILE, NII, BIDS_Global_info, Log_Type, Print_Logger, Subject_Container, to_nii_seg
 
+logger = Print_Logger()
 SEGMENTATION_TO_SMALL_THRESHOLD = 3000
 
 
 def __test_seg_file(spinal_cord_file: Path):
     if spinal_cord_file.exists():
         try:
             data = to_nii_seg(spinal_cord_file).get_seg_array()
@@ -27,44 +28,53 @@
         return False
     return True
 
 
 ignore_list = ["No properties for slice"]
 
 
-def run_cmd(cmd_ex: list[str], ouf_file: Path | None = None, print_ignore_list: list[str] | None = None, verbose=True) -> int:
+def run_cmd(
+    cmd_ex: list[str],
+    out_file: Path | None = None,
+    print_ignore_list: list[str] | None = None,
+    verbose=True,
+    override=False,
+    logger=logger,
+) -> int:
     """Runs the command in the list
 
     Args:
         cmd_ex (list[str]): Command line argument. Instead of whitespaces us a list to separate tokens. All whitespaces must be removed or they will be part of the Token.
         ouf_file (Path, optional): Prints f'[#] Saved to {ouf_file}', if given. Defaults to None.
 
     Returns:
         int: Error-Code
     """
-
+    if not override and out_file is not None and out_file.exists():
+        logger.print(f"[#] Exist; Skip {out_file!s}", Log_Type.OK)
+        return 0
     if print_ignore_list is None:
         print_ignore_list = []
     process = subprocess.Popen(cmd_ex, stdout=subprocess.PIPE, universal_newlines=True)
 
     while True:
         assert process.stdout is not None
         output = process.stdout.readline()
         if output != "":
-            print("[S]", output.strip()) if verbose else None
+            logger.print("[SCT]", output.strip()) if verbose else None
         # Do something else
         return_code = process.poll()
         if return_code is not None:
             # Process has finished, read rest of the output
             for output in process.stdout.readlines():
                 time.sleep(0.001)
                 print(output.strip(), print_ignore_list) if verbose else None
-            print("[#] RETURN CODE", return_code) if verbose else None
-            if ouf_file is not None:
-                print(f"[#] Saved to {ouf_file!s}") if verbose else None
+            logger.print("[#] RETURN CODE", return_code, Log_Type.OK) if verbose else None
+            if out_file is not None and return_code == 0:
+                logger.print(f"[#] Saved to {out_file!s}", Log_Type.SAVE) if verbose else None
             break
     return return_code
 
 
 def compute_spinal_cord(file: BIDS_FILE, override=False, hot=True, do_label=True, **args):
     """Runs the spinalcord file
 
@@ -109,15 +119,15 @@
         print(cmd_ex_cord)
 
 
 def compute_spinal_cord_with_cut_sacrum(
     mri_file: BIDS_FILE,
     msk_file: BIDS_FILE,
     parent_folder_name="derivatives",
-    verbos=True,
+    verbose=True,
     **args,
 ):
     """Runs the spinalcord file, but before it uses a point msk or vertebra segmentation to remove the sacrum.
     This function only execute when there is the L4 (id 23) present and at least 4 other vertebra segmentation.
 
     Args:
         mri_file (BIDS_FILE): The image in the format set in domain, default is T2
@@ -127,57 +137,57 @@
         threshold (float, optional): Custom Threshold. Defaults to -1 and means the preset threshold is used.
         out_file (Path | None, optional): override the default out_file. Defaults to None.
         parent_folder_name: Parentfolder (like rawdata/derivatives). Defaults to "derivatives"
         override (bool): override only if set to True
     Returns:
         bool: if the function tried to compute it.
     """
-    if verbos:
+    if verbose:
         print("[*] Try to segment spinalcord by cutting away the vertebra.")
     # Check if the mask is applicable
     msk_nii = msk_file.open_nii_reorient(axcodes_to=("A", "S", "R"))
     msk_arr = msk_nii.get_array()
     loc = np.where(msk_arr == 23)  # L4
     if len(loc) == 0 or len(loc[0]) == 0:
-        if verbos:
+        if verbose:
             print("[?] No L4 Vertebra")
         return False
     # -1 is to remove the 0 (Background)
     num_vertebras = len(np.unique(msk_arr[:, loc[1][1] :])) - 1
     if num_vertebras < 4:
-        if verbos:
+        if verbose:
             print(f"[?] Not enough Vertebras. Ids:{np.unique(msk_arr[:, loc[1][1] :])}")
         return False
     # Load MRI and cut
     mri_nii = mri_file.open_nii_reorient(axcodes_to=("A", "S", "R"))
     mri_arr = mri_nii.get_array()
     out_cut = mri_arr[:, loc[1][1] :].copy()
-    tmp = os.path.join("/tmp", f"temp_{secrets.token_urlsafe(21)}_cord")
+    tmp = Path("/tmp", f"temp_{secrets.token_urlsafe(21)}_cord")
     try:
         if not Path(tmp).exists():
             Path(tmp).mkdir()
         # Run spinalcord tools
         mri_path = str(Path(tmp, "mri.nii.gz"))
         nib.save(nib.Nifti1Image(out_cut, mri_nii.affine, mri_nii.header), str(mri_path))
         out_file = __bids2spinalcord(mri_file, parent_folder_name=parent_folder_name)
         cmd_ex_cord, spinal_cord_file = get_cmd_ex_spinal_cord(mri_path, out_file=out_file, **args)
         run_cmd(cmd_ex_cord, print_ignore_list=ignore_list)
         # revert padding
-        if verbos:
+        if verbose:
             print("[*] revert padding")
         arr = NII(nib.load(spinal_cord_file), seg=True).get_seg_array()
         out = mri_arr.copy()
         out *= 0
         out[:, loc[1][1] :] = arr
         if out.sum() <= 1000:
             print(f"[?] Failed. There are only {out.sum()} pixel.")
             return False
         out_nib = NII(nib.Nifti1Image(out, mri_nii.affine, mri_nii.header))
-        out_nib.reorient_same_as_(mri_file.open_nii(), verbose=verbos)
-        out_nib.save(spinal_cord_file, verbose=verbos)
+        out_nib.reorient_same_as_(mri_file.open_nii(), verbose=verbose)
+        out_nib.save(spinal_cord_file, verbose=verbose)
     except Exception:  # noqa: TRY302
         raise
     finally:
         shutil.rmtree(tmp)
     return True
 
 
@@ -278,18 +288,15 @@
     Returns:
         tuple[list[str], BIDS_FILE]: The cmd command and the output filepath
     """
     if out_file is None:
         out_file = __bids2spinalcord(bids_file, parent_folder_name=parent_folder_name)
     if not override and out_file.exists():
         return ["echo", f"[?] the spinalcord already exists {out_file.name}."], out_file
-    if isinstance(bids_file, Path | str):
-        in_file = str(bids_file)
-    else:
-        in_file = bids_file.file["nii.gz"]
+    in_file = str(bids_file) if isinstance(bids_file, Path | str) else bids_file.file["nii.gz"]
     # sct_deepseg_sc -i sub-spinegan0008_ses-20210204_sequ-302_e-1_dixon.nii.gz -c t2 -brain 0 -o text.nii.gz
     cmd_ex = ["sct_deepseg_sc", "-i", in_file, "-c", domain, "-brain", "0", "-o", str(out_file)]
     if threshold != -1:
         cmd_ex += ["-thr", str(threshold)]
     return cmd_ex, out_file
 
 
@@ -315,15 +322,15 @@
 def get_cmd_ex_label(
     bids_file: BIDS_FILE,
     spinal_cord_file: Path,
     domain: str = "t2",
     out_file: Path | None = None,
     parent_folder_name: str = "derivatives",
     override=False,
-    **args,
+    **args,  # noqa: ARG001
 ) -> tuple[list[str], Path]:
     """Defines the output file and the run command to split the spinal cord segmentation into vertebrae-label with spinalcordtoolbox
     The output is a folder, for easier use there is a rapping function 'run_get_cmd_ex_label'
 
     Args:
         bids_file (BIDS_FILE): The image.
         spinal_cord_file (BIDS_FILE): spinalcord.
@@ -365,18 +372,18 @@
 
     if return_code != 0:
         return
     if not Path(cmd_ex[-1]).exists():
         print("[!] the temporary output files are missing")
         return
     file1 = Path(cmd_ex[-1], name + "_labeled.nii.gz")  # Seg same as spinalcord but with vertebrae-label
-    file2 = Path(cmd_ex[-1], name + "_labeled_discs.nii.gz")  # source points of the labels (points where the vertebra-label changes)
-    file3 = Path(cmd_ex[-1], "straight_ref.nii.gz")  # The spine straightened
-    file4 = Path(cmd_ex[-1], "warp_curve2straight.nii.gz")  # Distortion field
-    file5 = Path(cmd_ex[-1], "warp_straight2curve.nii.gz")  # Distortion field
+    # file2 = Path(cmd_ex[-1], name + "_labeled_discs.nii.gz")  # source points of the labels (points where the vertebra-label changes)
+    # file3 = Path(cmd_ex[-1], "straight_ref.nii.gz")  # The spine straightened
+    # file4 = Path(cmd_ex[-1], "warp_curve2straight.nii.gz")  # Distortion field
+    # file5 = Path(cmd_ex[-1], "warp_straight2curve.nii.gz")  # Distortion field
     import shutil
 
     # /tmp/sub-spinegan0042_ses-20220517_sequ-301_e-1_label-cord_label_msk
     # sub-spinegan0042_ses-20220517_sequ-301_e-1_label-spinalcord_msk_labeled.nii.gz
 
     shutil.copy(str(file1), str(out_file))
     shutil.rmtree(cmd_ex[-1])
```

## Comparing `tptbox-0.1.0.dist-info/LICENSE` & `tptbox-0.1.1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `tptbox-0.1.0.dist-info/METADATA` & `tptbox-0.1.1.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: TPTBox
-Version: 0.1.0
+Version: 0.1.1
 Summary: A Torso Processing Toolbox capable of processing BIDS-compatible datasets, singular niftys, points of interests, segmentations, and much more.
 Home-page: https://github.com/Hendrik-code/TPTBox
 License: GNU AFFERO GENERAL PUBLIC LICENSE v3.0, 19 November 2007
 Author: Robert Graf
 Author-email: robert.graf@tum.de
 Requires-Python: >=3.10,<4.0
 Classifier: License :: Other/Proprietary License
```

## Comparing `tptbox-0.1.0.dist-info/RECORD` & `tptbox-0.1.1.dist-info/RECORD`

 * *Files 9% similar despite different names*

```diff
@@ -1,43 +1,45 @@
 TPTBox/__init__.py,sha256=dLdT0MXmNt3zIUfknLbkamVa-x3vxLjUc2w4_IViJ90,1119
 TPTBox/core/__init__.py,sha256=iMKh_SsaaHczAmq_4Cy17ZWZ7oIpW1rdj0WeGfLOQ4g,619
 TPTBox/core/bids_constants.py,sha256=G18_6qk0F_eHv-fan30KmD9sWONvfeMWOgaVANaTd4I,3972
 TPTBox/core/bids_files.py,sha256=zWUe0OwfYee_M3z1V22OTKAicp8Jd4otvMEaEpeqSp4,55801
 TPTBox/core/nii_wrapper.py,sha256=mzw3mKDhW2vX1lGsUnR4_Tn0DtIsBlfb3GCgALWQSUo,64166
 TPTBox/core/nii_wrapper_math.py,sha256=Qb50sYDVuMPWui31C_hjZkbRrlZwUwpgVtyoyAGcoP8,9151
 TPTBox/core/np_utils.py,sha256=baioyRE36MGwsYb0Zx0WQQrRdxV6Uf3-wW6cr6vaVsQ,37507
-TPTBox/core/poi.py,sha256=1OlqW2Y_XjFWyF5r5CASJY7sZPXjgYe4cbeStMv8juE,69391
-TPTBox/core/poi_abstract.py,sha256=4L0HKUx-R4-Gj2R7rdq_BAgkXpokOnj62qc9J13VCO4,28688
+TPTBox/core/poi.py,sha256=WM8A_ksGBjubPqIi1w0OxeStmCkyQoYKvItL-3MHpmo,69550
+TPTBox/core/poi_abstract.py,sha256=skEEGqK4iYbpGKLYFvphvixU1409IdxHhQQxJa5mpms,28761
 TPTBox/core/poi_global.py,sha256=rU08hHG0YpUTGYxj1X2d2idyp44LRjylcNU85zHNEmI,2907
 TPTBox/core/sitk_utils.py,sha256=WPsD8mW8Gjvrc0aFUByagiv8PSHVTmhZ-F_KoIHfisc,18197
 TPTBox/core/vert_constants.py,sha256=3NJskOIzrkdssBwha-_abBSir2rQjtSVzHigmWSa4QY,7861
-TPTBox/core/vertebra_pois_non_centroids.py,sha256=tOQXZV7IjJlcJeqe3po58J7dMVUfRvWC0KDFi-ToYdg,45577
+TPTBox/core/vertebra_pois_non_centroids.py,sha256=SExcejChqwtGcDDqZhGLbCkOkVJpvUOWabS0hmyX7YY,47636
 TPTBox/docker/__init__.py,sha256=ln-Xk0IkOyoYkfti6nZruiwhH7_bQmprrpLY5dUXCnE,207
 TPTBox/docker/docker.py,sha256=9f_zgvnHZTpJmjUfKWbl3mtyeRN5J63jyotNgLNbuKA,36551
 TPTBox/docker/docker_run.py,sha256=UQv-qpYFDnUU4VojxxozaKzQWovfEFbFGi1hNPbutCg,1392
 TPTBox/logger/__init__.py,sha256=JFjqzAZ6Tjq40hXMqXtHwSut-o3dBcYBtqhcQamMXZI,165
 TPTBox/logger/log_constants.py,sha256=W2A4KjOXV8m3Hi0gxZJN_nvEL1DRBiv-ljpAmY_NT5I,5063
-TPTBox/logger/log_file.py,sha256=0FFqFovuBnQUz77p1PlyNzj0KED8gHSxQtG2Iq9U37w,15027
+TPTBox/logger/log_file.py,sha256=1AeIHvgVvPxpF8Rn6iy0r6hSr5MmHPjTYVxbTLTe_QM,15482
 TPTBox/mesh3D/mesh.py,sha256=-p-piOao9RPFbbdn46UTYhtCnUqW2PeFCGsNilDG_wY,4836
 TPTBox/mesh3D/mesh_colors.py,sha256=PCO7pUf8tglbJ_l8sDx9CuhzpVFs2mQn-VcdJcwo3lk,4633
 TPTBox/registration/__init__.py,sha256=rP0Cc84NU66ZDIHvsvTn1ygPCsMLL6o7njpPoZxA_R8,418
 TPTBox/registration/_deepali/test.py,sha256=o9jGhDJLHIK00DN_DpJDKVMFobJxbWEJppRS1EGE0xQ,13413
 TPTBox/registration/ridged_intensity/register.py,sha256=hE29j2moTI23pyZYbmZOWDzpmwzt6XW1rdOZREugJLM,3715
 TPTBox/registration/ridged_points/__init__.py,sha256=4H0bpP143SWiLRVX8lPpFqVgG4p6T6TZrlbiWGRyyS0,144
 TPTBox/registration/ridged_points/point_registration.py,sha256=0xof8xDxnuMnTpDXBg6knLVTYAYXd1jR0NOOTPN-mbw,11219
 TPTBox/registration/script_ax2sag.py,sha256=nXAKJHKA006Yau9G1qiVRJh3kPVIvdgUhBVnhm72S-o,7039
 TPTBox/registration/script_ax2sag_v2.py,sha256=tHBOdRV-_-Hca_j9gyn-U3xuW_hLXURVgNE4omzgaYw,13839
 TPTBox/spine/POI_plotter.py,sha256=5ICeKRfz-i4TBkRkY6GsfBZld48B35W81WdrDuunUrM,8053
 TPTBox/spine/mesh3D/vert_mesh_colors.py,sha256=MUK_xLz0rPA3ArkuvwNI9TFVrrzyJTDea8l4p-0h-uA,835
+TPTBox/spine/segmentation/__init__.py,sha256=zbNZqStPri6m1aBA68dg2Qytu7y7iQX-sL1moB8XDAQ,44
+TPTBox/spine/segmentation/spineps.py,sha256=oWx3D9c-2s5htSa1pIvQ4zg2bqF2VSXVUbbFQ0_PPE0,2125
 TPTBox/spine/snapshot2D/__init__.py,sha256=0Tdrhrs3Rb4fALXnbCdn3NdfpRXKYIIXfi9m0wtnY68,221
 TPTBox/spine/snapshot2D/snapshot_modular.py,sha256=c9yMs8iAGCo0ZAfgV0Lin5atGH6w74Sz9tHpdWpMuvo,33768
 TPTBox/spine/snapshot2D/snapshot_templates.py,sha256=AYO_7OjxZVecQysaYGS4lZx_sARdzOi1JdKGd0iEXvA,15619
 TPTBox/spine/spinal_cord_segmentation/__count_segmented.py,sha256=IFdZVCzX-n5JbpbE3aXzbDPd-pJcfL4OBp8fv1Y9s7Q,2156
 TPTBox/spine/spinal_cord_segmentation/__init__.py,sha256=AbpHGcgLb-kRsJGnwFEktk7uzpZOCcBY74-YBdrKVGs,1
-TPTBox/spine/spinal_cord_segmentation/seg_spinalcordtoolbox.py,sha256=xlOV0uQgP5GBc2YMev8b24ufCPlI-rj5D8is1XqPPco,19735
+TPTBox/spine/spinal_cord_segmentation/seg_spinalcordtoolbox.py,sha256=4mk7zqsQ_pj9IZ9X2_gZea0N3REgaFbXESigKvFh6do,20055
 TPTBox/stitching/README.md,sha256=jIi2TKigB029La2YeJAec878E7EelU7YCWDcYr-dWXo,2256
 TPTBox/stitching/__init__.py,sha256=bWSBRWS7LstJjZxZI1m4OTezXXthdz2zoT2krOa8YwE,86
 TPTBox/stitching/__stitching_reg.py,sha256=SMKt5bihGXMyOU7-ua1alKfn2FPbA92llckLBToQ11w,11308
 TPTBox/stitching/__stitching_vertical.py,sha256=SngTW9YO0YpjDVVTuQVAtYhc5SkjfmNzBFDPPGgwfBo,10048
 TPTBox/stitching/stitching.jpg,sha256=zUSjKVWNqJdlod-uQvqd_gqvq3ZoLkpgZQaS3TkiJ5Q,326043
 TPTBox/stitching/stitching.py,sha256=0Dw7xGQXlZBorDUFjX0aZg_FTi7lYFsKQOgcwXJBeqk,22293
 TPTBox/stitching/stitching_tools.py,sha256=Jt03jN6CW3wD90dCxLnERiP041IOhrC-uR2dU28FzEI,4427
@@ -48,11 +50,11 @@
 TPTBox/tests/sample_mri/sub-mri_label-6_T2w.nii.gz,sha256=lhSVtCzfwC6vUOs_Rx1wV5O4KAL-2wX18CqlNnUoz0Q,259999
 TPTBox/tests/sample_mri/sub-mri_seg-subreg_label-6_msk.nii.gz,sha256=NMej3czue1ApUdluDMwL90mP8_nEenvfzvtRp-PKJ4U,12846
 TPTBox/tests/sample_mri/sub-mri_seg-vert_label-6_msk.nii.gz,sha256=FO5yej9WVRLdvwydjOjZzhJ6zEPw0hvHdxwvy9NDAjo,12144
 TPTBox/tests/speedtest.py,sha256=_HlkDuREjFCWuwyReKnYpLSLxw5XRXlogWQj2A11r_w,1756
 TPTBox/tests/speedtest_cc3d.py,sha256=NWPxZ8tu46LgxsJpceKBbKsSUhdzIHkQC9yHRy9S8CE,2871
 TPTBox/tests/speedtest_morphological.py,sha256=NdQWYwN6CZSgixYhXMuXFZfOcmn2DRzw0oGuw0eKUg4,1045
 TPTBox/tests/test_utils.py,sha256=OqGYNIt3eyq3uNzx5ltcGpFrTSnqeonRIP3NAEDs7q8,11959
-tptbox-0.1.0.dist-info/LICENSE,sha256=hIahDEOTzuHCU5J2nd07LWwkLW7Hko4UFO__ffsvB-8,34523
-tptbox-0.1.0.dist-info/METADATA,sha256=3m-3dFs0_KDH03yF8aujq13i6rSp8kRgUq9Al5fRcfg,4337
-tptbox-0.1.0.dist-info/WHEEL,sha256=sP946D7jFCHeNz5Iq4fL4Lu-PrWrFsgfLXbbkciIZwg,88
-tptbox-0.1.0.dist-info/RECORD,,
+tptbox-0.1.1.dist-info/LICENSE,sha256=hIahDEOTzuHCU5J2nd07LWwkLW7Hko4UFO__ffsvB-8,34523
+tptbox-0.1.1.dist-info/METADATA,sha256=sFvib_RbmiSHuoEacklY2sby2xBVqi69E4p4-wtSSJg,4337
+tptbox-0.1.1.dist-info/WHEEL,sha256=sP946D7jFCHeNz5Iq4fL4Lu-PrWrFsgfLXbbkciIZwg,88
+tptbox-0.1.1.dist-info/RECORD,,
```

