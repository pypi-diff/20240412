# Comparing `tmp/pytket_cutensornet-0.5.4-py3-none-any.whl.zip` & `tmp/pytket_cutensornet-0.6.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,20 +1,23 @@
-Zip file size: 46003 bytes, number of entries: 18
--rw-r--r--  2.0 unx     1066 b- defN 24-Jan-23 15:06 pytket/extensions/cutensornet/__init__.py
--rw-r--r--  2.0 unx       74 b- defN 24-Jan-23 15:07 pytket/extensions/cutensornet/_metadata.py
--rw-r--r--  2.0 unx     1423 b- defN 24-Jan-23 15:06 pytket/extensions/cutensornet/general.py
--rw-r--r--  2.0 unx        0 b- defN 24-Jan-23 15:06 pytket/extensions/cutensornet/py.typed
--rw-r--r--  2.0 unx    28993 b- defN 24-Jan-23 15:06 pytket/extensions/cutensornet/tensor_network_convert.py
--rw-r--r--  2.0 unx     2630 b- defN 24-Jan-23 15:06 pytket/extensions/cutensornet/utils.py
--rw-r--r--  2.0 unx      705 b- defN 24-Jan-23 15:06 pytket/extensions/cutensornet/backends/__init__.py
--rw-r--r--  2.0 unx    10848 b- defN 24-Jan-23 15:06 pytket/extensions/cutensornet/backends/cutensornet_backend.py
--rw-r--r--  2.0 unx     1115 b- defN 24-Jan-23 15:06 pytket/extensions/cutensornet/mps/__init__.py
--rw-r--r--  2.0 unx    43207 b- defN 24-Jan-23 15:06 pytket/extensions/cutensornet/mps/mps.py
--rw-r--r--  2.0 unx    10401 b- defN 24-Jan-23 15:06 pytket/extensions/cutensornet/mps/mps_gate.py
--rw-r--r--  2.0 unx    22948 b- defN 24-Jan-23 15:06 pytket/extensions/cutensornet/mps/mps_mpo.py
--rw-r--r--  2.0 unx     9381 b- defN 24-Jan-23 15:06 pytket/extensions/cutensornet/mps/simulation.py
--rw-r--r--  2.0 unx    11356 b- defN 24-Jan-23 15:07 pytket_cutensornet-0.5.4.dist-info/LICENSE
--rw-r--r--  2.0 unx     5102 b- defN 24-Jan-23 15:07 pytket_cutensornet-0.5.4.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Jan-23 15:07 pytket_cutensornet-0.5.4.dist-info/WHEEL
--rw-r--r--  2.0 unx        7 b- defN 24-Jan-23 15:07 pytket_cutensornet-0.5.4.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1767 b- defN 24-Jan-23 15:07 pytket_cutensornet-0.5.4.dist-info/RECORD
-18 files, 151115 bytes uncompressed, 43013 bytes compressed:  71.5%
+Zip file size: 67422 bytes, number of entries: 21
+-rw-r--r--  2.0 unx     1066 b- defN 24-Apr-12 13:37 pytket/extensions/cutensornet/__init__.py
+-rw-r--r--  2.0 unx       74 b- defN 24-Apr-12 13:37 pytket/extensions/cutensornet/_metadata.py
+-rw-r--r--  2.0 unx     1423 b- defN 24-Apr-12 13:37 pytket/extensions/cutensornet/general.py
+-rw-r--r--  2.0 unx        0 b- defN 24-Apr-12 13:37 pytket/extensions/cutensornet/py.typed
+-rw-r--r--  2.0 unx    29034 b- defN 24-Apr-12 13:37 pytket/extensions/cutensornet/tensor_network_convert.py
+-rw-r--r--  2.0 unx     2630 b- defN 24-Apr-12 13:37 pytket/extensions/cutensornet/utils.py
+-rw-r--r--  2.0 unx      705 b- defN 24-Apr-12 13:37 pytket/extensions/cutensornet/backends/__init__.py
+-rw-r--r--  2.0 unx    10848 b- defN 24-Apr-12 13:37 pytket/extensions/cutensornet/backends/cutensornet_backend.py
+-rw-r--r--  2.0 unx     1212 b- defN 24-Apr-12 13:37 pytket/extensions/cutensornet/structured_state/__init__.py
+-rw-r--r--  2.0 unx    16125 b- defN 24-Apr-12 13:37 pytket/extensions/cutensornet/structured_state/general.py
+-rw-r--r--  2.0 unx    36986 b- defN 24-Apr-12 13:37 pytket/extensions/cutensornet/structured_state/mps.py
+-rw-r--r--  2.0 unx    10290 b- defN 24-Apr-12 13:37 pytket/extensions/cutensornet/structured_state/mps_gate.py
+-rw-r--r--  2.0 unx    22744 b- defN 24-Apr-12 13:37 pytket/extensions/cutensornet/structured_state/mps_mpo.py
+-rw-r--r--  2.0 unx    16196 b- defN 24-Apr-12 13:37 pytket/extensions/cutensornet/structured_state/simulation.py
+-rw-r--r--  2.0 unx    33943 b- defN 24-Apr-12 13:37 pytket/extensions/cutensornet/structured_state/ttn.py
+-rw-r--r--  2.0 unx    32454 b- defN 24-Apr-12 13:37 pytket/extensions/cutensornet/structured_state/ttn_gate.py
+-rw-r--r--  2.0 unx    11356 b- defN 24-Apr-12 13:37 pytket_cutensornet-0.6.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     5102 b- defN 24-Apr-12 13:37 pytket_cutensornet-0.6.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-Apr-12 13:37 pytket_cutensornet-0.6.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx        7 b- defN 24-Apr-12 13:37 pytket_cutensornet-0.6.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2175 b- defN 24-Apr-12 13:37 pytket_cutensornet-0.6.0.dist-info/RECORD
+21 files, 234462 bytes uncompressed, 63738 bytes compressed:  72.8%
```

## zipnote {}

```diff
@@ -18,38 +18,47 @@
 
 Filename: pytket/extensions/cutensornet/backends/__init__.py
 Comment: 
 
 Filename: pytket/extensions/cutensornet/backends/cutensornet_backend.py
 Comment: 
 
-Filename: pytket/extensions/cutensornet/mps/__init__.py
+Filename: pytket/extensions/cutensornet/structured_state/__init__.py
 Comment: 
 
-Filename: pytket/extensions/cutensornet/mps/mps.py
+Filename: pytket/extensions/cutensornet/structured_state/general.py
 Comment: 
 
-Filename: pytket/extensions/cutensornet/mps/mps_gate.py
+Filename: pytket/extensions/cutensornet/structured_state/mps.py
 Comment: 
 
-Filename: pytket/extensions/cutensornet/mps/mps_mpo.py
+Filename: pytket/extensions/cutensornet/structured_state/mps_gate.py
 Comment: 
 
-Filename: pytket/extensions/cutensornet/mps/simulation.py
+Filename: pytket/extensions/cutensornet/structured_state/mps_mpo.py
 Comment: 
 
-Filename: pytket_cutensornet-0.5.4.dist-info/LICENSE
+Filename: pytket/extensions/cutensornet/structured_state/simulation.py
 Comment: 
 
-Filename: pytket_cutensornet-0.5.4.dist-info/METADATA
+Filename: pytket/extensions/cutensornet/structured_state/ttn.py
 Comment: 
 
-Filename: pytket_cutensornet-0.5.4.dist-info/WHEEL
+Filename: pytket/extensions/cutensornet/structured_state/ttn_gate.py
 Comment: 
 
-Filename: pytket_cutensornet-0.5.4.dist-info/top_level.txt
+Filename: pytket_cutensornet-0.6.0.dist-info/LICENSE
 Comment: 
 
-Filename: pytket_cutensornet-0.5.4.dist-info/RECORD
+Filename: pytket_cutensornet-0.6.0.dist-info/METADATA
+Comment: 
+
+Filename: pytket_cutensornet-0.6.0.dist-info/WHEEL
+Comment: 
+
+Filename: pytket_cutensornet-0.6.0.dist-info/top_level.txt
+Comment: 
+
+Filename: pytket_cutensornet-0.6.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## pytket/extensions/cutensornet/_metadata.py

```diff
@@ -1,2 +1,2 @@
-__extension_version__ = "0.5.4"
+__extension_version__ = "0.6.0"
 __extension_name__ = "pytket-cutensornet"
```

## pytket/extensions/cutensornet/tensor_network_convert.py

```diff
@@ -174,15 +174,15 @@
             reversed order of circuit graph nodes.
         """
         self._gate_tensors = self._get_gate_tensors(adj=adj)
         node_tensors = []
         self._input_nodes = []
         self._output_nodes = []
         for i, node in reversed(list(enumerate(self._network.nodes(data=True)))):
-            if node[1]["desc"] not in ("Input", "Output"):
+            if node[1]["desc"] not in ("Input", "Output", "Create"):
                 n_out_edges = len(list(self._network.out_edges(node[0])))
                 if n_out_edges > 1:
                     src_ports = [
                         edge[-1]["src_port"]
                         for edge in self._network.out_edges(node[0], data=True)
                     ]
                     unit_idx = [
@@ -209,15 +209,15 @@
                         self._logger.debug(f"Adding a downward gate tensor")
                 else:
                     node_tensors.append(self._gate_tensors[node[1]["desc"]][0])
                     self._logger.debug(f"Adding a 1-qubit gate tensor")
             else:
                 if node[1]["desc"] == "Output":
                     self._output_nodes.append(i)
-                if node[1]["desc"] == "Input":
+                if node[1]["desc"] == "Input" or node[1]["desc"] == "Create":
                     self._input_nodes.append(i)
                     node_tensors.append(np.array([1, 0], dtype="complex128"))
         if adj:
             node_tensors.reverse()
         self._logger.debug(f"Node tensors: \n{node_tensors}\n")
 
         return node_tensors
```

## Comparing `pytket/extensions/cutensornet/mps/__init__.py` & `pytket/extensions/cutensornet/structured_state/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -7,31 +7,24 @@
 #     http://www.apache.org/licenses/LICENSE-2.0
 ##
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
-"""Module for circuit simulation by state evolution, with states represented as
-Matrix Product States (MPS). Approximate tensor network contraction is supported.
-For an example of its use, see ``examples/mps_tutorial.ipynb`` in
+"""Module for circuit simulation by state evolution, where the state is
+represented by a tensor network with a predefined structure.
+Approximate tensor network contraction is supported. Both ``MPS`` and ``TTN``
+methods are provided.
+For an example of its use, see the ``examples/`` folder at
 https://github.com/CQCL/pytket-cutensornet.
 """
 
-from .mps import (
-    CuTensorNetHandle,
-    DirectionMPS,
-    ConfigMPS,
-    Handle,
-    Tensor,
-    MPS,
-)
+from .general import CuTensorNetHandle, Config, StructuredState
+from .simulation import SimulationAlgorithm, simulate, prepare_circuit_mps
 
-from .mps_gate import (
-    MPSxGate,
-)
+from .mps import DirMPS, MPS
+from .mps_gate import MPSxGate
+from .mps_mpo import MPSxMPO
 
-from .mps_mpo import (
-    MPSxMPO,
-)
-
-from .simulation import ContractionAlg, simulate, prepare_circuit
+from .ttn import TTN, DirTTN
+from .ttn_gate import TTNxGate
```

## Comparing `pytket/extensions/cutensornet/mps/mps.py` & `pytket/extensions/cutensornet/structured_state/mps.py`

 * *Files 11% similar despite different names*

```diff
@@ -9,225 +9,72 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 from __future__ import annotations  # type: ignore
 import warnings
-import logging
-from typing import Any, Optional, Union
+from typing import Union
 from enum import Enum
 
 from random import random  # type: ignore
 import numpy as np  # type: ignore
 
 try:
     import cupy as cp  # type: ignore
 except ImportError:
     warnings.warn("local settings failed to import cupy", ImportWarning)
 try:
     import cuquantum as cq  # type: ignore
-    import cuquantum.cutensornet as cutn  # type: ignore
     from cuquantum.cutensornet import tensor  # type: ignore
 except ImportError:
     warnings.warn("local settings failed to import cutensornet", ImportWarning)
 
 from pytket.circuit import Command, Op, OpType, Qubit
 from pytket.pauli import Pauli, QubitPauliString
 
 from pytket.extensions.cutensornet.general import set_logger
 
-# An alias so that `intptr_t` from CuQuantum's API (which is not available in
-# base python) has some meaningful type name.
-Handle = int
-# An alias for the CuPy type used for tensors
-try:
-    Tensor = cp.ndarray
-except NameError:
-    Tensor = Any
+from .general import CuTensorNetHandle, Config, StructuredState, Tensor
 
 
-class DirectionMPS(Enum):
+class DirMPS(Enum):
     """An enum to refer to relative directions within the MPS."""
 
     LEFT = 0
     RIGHT = 1
 
 
-class CuTensorNetHandle:
-    """Initialise the cuTensorNet library with automatic workspace memory
-    management.
-
-    Note:
-        Always use as ``with CuTensorNetHandle() as libhandle:`` so that cuTensorNet
-        handles are automatically destroyed at the end of execution.
-
-    Attributes:
-        handle (int): The cuTensorNet library handle created by this initialisation.
-        device_id (int): The ID of the device (GPU) where cuTensorNet is initialised.
-            If not provided, defaults to ``cp.cuda.Device()``.
-    """
-
-    def __init__(self, device_id: Optional[int] = None):
-        self.handle = cutn.create()
-        self._is_destroyed = False
-
-        # Make sure CuPy uses the specified device
-        cp.cuda.Device(device_id).use()
-
-        dev = cp.cuda.Device()
-        self.device_id = int(dev)
-
-    def __enter__(self) -> CuTensorNetHandle:
-        return self
-
-    def __exit__(self, exc_type: Any, exc_value: Any, exc_tb: Any) -> None:
-        cutn.destroy(self.handle)
-        self._is_destroyed = True
-
-
-class ConfigMPS:
-    """Configuration class for simulation using MPS."""
-
-    def __init__(
-        self,
-        chi: Optional[int] = None,
-        truncation_fidelity: Optional[float] = None,
-        k: int = 4,
-        optim_delta: float = 1e-5,
-        float_precision: Union[np.float32, np.float64] = np.float64,  # type: ignore
-        value_of_zero: float = 1e-16,
-        loglevel: int = logging.WARNING,
-    ):
-        """Instantiate a configuration object for MPS simulation.
-
-        Note:
-            Providing both a custom ``chi`` and ``truncation_fidelity`` will raise an
-            exception. Choose one or the other (or neither, for exact simulation).
-
-        Args:
-            chi: The maximum value allowed for the dimension of the virtual
-                bonds. Higher implies better approximation but more
-                computational resources. If not provided, ``chi`` will be unbounded.
-            truncation_fidelity: Every time a two-qubit gate is applied, the virtual
-                bond will be truncated to the minimum dimension that satisfies
-                ``|<psi|phi>|^2 >= trucantion_fidelity``, where ``|psi>`` and ``|phi>``
-                are the states before and after truncation (both normalised).
-                If not provided, it will default to its maximum value 1.
-            k: If using MPSxMPO, the maximum number of layers the MPO is allowed to
-                have before being contracted. Increasing this might increase fidelity,
-                but it will also increase resource requirements exponentially.
-                Ignored if not using MPSxMPO. Default value is 4.
-            optim_delta: If using MPSxMPO, stopping criteria for the optimisation when
-                contracting the ``k`` layers of MPO. Stops when the increase of fidelity
-                between iterations is smaller than ``optim_delta``.
-                Ignored if not using MPSxMPO. Default value is ``1e-5``.
-            float_precision: The floating point precision used in tensor calculations;
-                choose from ``numpy`` types: ``np.float64`` or ``np.float32``.
-                Complex numbers are represented using two of such
-                ``float`` numbers. Default is ``np.float64``.
-            value_of_zero: Any number below this value will be considered equal to zero.
-                Even when no ``chi`` or ``truncation_fidelity`` is provided, singular
-                values below this number will be truncated.
-                We suggest to use a value slightly below what your chosen
-                ``float_precision`` can reasonably achieve. For instance, ``1e-16`` for
-                ``np.float64`` precision (default) and ``1e-7`` for ``np.float32``.
-            loglevel: Internal logger output level. Use 30 for warnings only, 20 for
-                verbose and 10 for debug mode.
-
-        Raises:
-            ValueError: If both ``chi`` and ``truncation_fidelity`` are fixed.
-            ValueError: If the value of ``chi`` is set below 2.
-            ValueError: If the value of ``truncation_fidelity`` is not in [0,1].
-        """
-        if (
-            chi is not None
-            and truncation_fidelity is not None
-            and truncation_fidelity != 1.0
-        ):
-            raise ValueError("Cannot fix both chi and truncation_fidelity.")
-        if chi is None:
-            chi = 2**60  # In practice, this is like having it be unbounded
-        if truncation_fidelity is None:
-            truncation_fidelity = 1
-
-        if chi < 2:
-            raise ValueError("The max virtual bond dim (chi) must be >= 2.")
-        if truncation_fidelity < 0 or truncation_fidelity > 1:
-            raise ValueError("Provide a value of truncation_fidelity in [0,1].")
-
-        self.chi = chi
-        self.truncation_fidelity = truncation_fidelity
-
-        if float_precision is None or float_precision == np.float64:  # Double precision
-            self._real_t = np.float64  # type: ignore
-            self._complex_t = np.complex128  # type: ignore
-            self._atol = 1e-12
-        elif float_precision == np.float32:  # Single precision
-            self._real_t = np.float32  # type: ignore
-            self._complex_t = np.complex64  # type: ignore
-            self._atol = 1e-4
-        else:
-            allowed_precisions = [np.float64, np.float32]
-            raise TypeError(
-                f"Value of float_precision must be in {allowed_precisions}."
-            )
-        self.zero = value_of_zero
-
-        if value_of_zero > self._atol / 1000:
-            warnings.warn(
-                "Your chosen value_of_zero is relatively large. "
-                "Faithfulness of final fidelity estimate is not guaranteed.",
-                UserWarning,
-            )
-
-        self.k = k
-        self.optim_delta = optim_delta
-        self.loglevel = loglevel
-
-    def copy(self) -> ConfigMPS:
-        """Standard copy of the contents."""
-        return ConfigMPS(
-            chi=self.chi,
-            truncation_fidelity=self.truncation_fidelity,
-            k=self.k,
-            optim_delta=self.optim_delta,
-            float_precision=self._real_t,  # type: ignore
-            value_of_zero=self.zero,
-            loglevel=self.loglevel,
-        )
-
-
-class MPS:
+class MPS(StructuredState):
     """Represents a state as a Matrix Product State.
 
     Attributes:
         tensors (list[Tensor]): A list of tensors in the MPS; ``tensors[0]`` is
             the leftmost and ``tensors[len(self)-1]`` is the rightmost; ``tensors[i]``
             and ``tensors[i+1]`` are connected in the MPS via a bond. All of the
             tensors are rank three, with the dimensions listed in ``.shape`` matching
             the left, right and physical bonds, in that order.
-        canonical_form (dict[int, Optional[DirectionMPS]]): A dictionary mapping
+        canonical_form (dict[int, Optional[DirMPS]]): A dictionary mapping
             positions to the canonical form direction of the corresponding tensor,
             or ``None`` if it the tensor is not canonicalised.
         qubit_position (dict[pytket.circuit.Qubit, int]): A dictionary mapping circuit
             qubits to the position its tensor is at in the MPS.
         fidelity (float): A lower bound of the fidelity, obtained by multiplying
             the fidelities after each contraction. The fidelity of a contraction
             corresponds to ``|<psi|phi>|^2`` where ``|psi>`` and ``|phi>`` are the
             states before and after truncation (assuming both are normalised).
     """
 
     def __init__(
         self,
         libhandle: CuTensorNetHandle,
         qubits: list[Qubit],
-        config: ConfigMPS,
+        config: Config,
     ):
-        """Initialise an MPS on the computational state ``|0>``.
+        """Initialise an MPS on the computational state ``|0>``
 
         Note:
             A ``libhandle`` should be created via a ``with CuTensorNet() as libhandle:``
             statement. The device where the MPS is stored will match the one specified
             by the library handle.
 
         Args:
@@ -242,32 +89,32 @@
         self._lib = libhandle
         self._cfg = config
         self._logger = set_logger("MPS", level=config.loglevel)
         self.fidelity = 1.0
 
         n_tensors = len(qubits)
         if n_tensors == 0:  # There's no initialisation to be done
-            return None
+            pass
         elif n_tensors == 1:
             raise ValueError("Please, provide at least two qubits.")
+        else:
+            self.qubit_position = {q: i for i, q in enumerate(qubits)}
 
-        self.qubit_position = {q: i for i, q in enumerate(qubits)}
-
-        # Create the list of tensors
-        self.tensors = []
-        self.canonical_form = {i: None for i in range(n_tensors)}
-
-        # Append each of the tensors initialised in state |0>
-        m_shape = (1, 1, 2)  # Two virtual bonds (dim=1) and one physical
-        for i in range(n_tensors):
-            m_tensor = cp.empty(m_shape, dtype=self._cfg._complex_t)
-            # Initialise the tensor to ket 0
-            m_tensor[0][0][0] = 1
-            m_tensor[0][0][1] = 0
-            self.tensors.append(m_tensor)
+            # Create the list of tensors
+            self.tensors: list[Tensor] = []
+            self.canonical_form = {i: None for i in range(n_tensors)}
+
+            # Append each of the tensors initialised in state |0>
+            m_shape = (1, 1, 2)  # Two virtual bonds (dim=1) and one physical
+            for i in range(n_tensors):
+                m_tensor = cp.empty(m_shape, dtype=self._cfg._complex_t)
+                # Initialise the tensor to ket 0
+                m_tensor[0][0][0] = 1
+                m_tensor[0][0][1] = 0
+                self.tensors.append(m_tensor)
 
     def is_valid(self) -> bool:
         """Verify that the MPS object is valid.
 
         Specifically, verify that the MPS does not exceed the dimension limit ``chi`` of
         the virtual bonds, that physical bonds have dimension 2, that all tensors
         are rank three and that the data structure sizes are consistent.
@@ -354,14 +201,26 @@
             raise RuntimeError(
                 "Gates must act on only 1 or 2 qubits! "
                 + f"This is not satisfied by {gate}."
             )
 
         return self
 
+    def apply_scalar(self, scalar: complex) -> MPS:
+        """Multiplies the state by a complex number.
+
+        Args:
+            scalar: The complex number to be multiplied.
+
+        Returns:
+            ``self``, to allow for method chaining.
+        """
+        self.tensors[0] *= scalar
+        return self
+
     def canonicalise(self, l_pos: int, r_pos: int) -> None:
         """Canonicalises the MPS object.
 
         Applies the necessary gauge transformations so that all MPS tensors
         to the left of position ``l_pos`` are in left orthogonal form and
         all MPS tensors to the right of ``r_pos`` in right orthogonal form.
 
@@ -370,34 +229,34 @@
                 canonicalised.
             r_pos: The position of the rightmost tensor that is not to be
                 canonicalised.
         """
         self._logger.debug(f"Start canonicalisation... l_pos={l_pos}, r_pos={r_pos}")
 
         for pos in range(l_pos):
-            self.canonicalise_tensor(pos, form=DirectionMPS.LEFT)
+            self.canonicalise_tensor(pos, form=DirMPS.LEFT)
         for pos in reversed(range(r_pos + 1, len(self))):
-            self.canonicalise_tensor(pos, form=DirectionMPS.RIGHT)
+            self.canonicalise_tensor(pos, form=DirMPS.RIGHT)
 
         self._logger.debug(f"Finished canonicalisation.")
 
-    def canonicalise_tensor(self, pos: int, form: DirectionMPS) -> None:
+    def canonicalise_tensor(self, pos: int, form: DirMPS) -> None:
         """Canonicalises a tensor from an MPS object.
 
         Applies the necessary gauge transformations so that the tensor at
         position ``pos`` in the MPS is in the orthogonal form dictated by
         ``form``.
 
         Args:
             position: The position of the tensor to be canonicalised.
             form: LEFT form means that its conjugate transpose is its inverse if
                 connected to its left bond and physical bond. Similarly for RIGHT.
 
         Raises:
-            ValueError: If ``form`` is not a value in ``DirectionMPS``.
+            ValueError: If ``form`` is not a value in ``DirMPS``.
             RuntimeError: If the ``CuTensorNetHandle`` is out of scope.
         """
         if form == self.canonical_form[pos]:
             # Tensor already in canonical form, nothing needs to be done
             self._logger.debug(f"Position {pos} already in {form}.")
             return None
 
@@ -415,32 +274,32 @@
         # p -> physical bond of T
         # P -> physical bond of Tnext
 
         # Gather the details from the MPS tensors at this position
         T = self.tensors[pos]
 
         # Assign the bond IDs
-        if form == DirectionMPS.LEFT:
+        if form == DirMPS.LEFT:
             next_pos = pos + 1
             Tnext = self.tensors[next_pos]
             T_bonds = "vsp"
             Q_bonds = "vap"
             R_bonds = "as"
             Tnext_bonds = "sVP"
             result_bonds = "aVP"
-        elif form == DirectionMPS.RIGHT:
+        elif form == DirMPS.RIGHT:
             next_pos = pos - 1
             Tnext = self.tensors[next_pos]
             T_bonds = "svp"
             Q_bonds = "avp"
             R_bonds = "as"
             Tnext_bonds = "VsP"
             result_bonds = "VaP"
         else:
-            raise ValueError("Argument form must be a value in DirectionMPS.")
+            raise ValueError("Argument form must be a value in DirMPS.")
 
         # Apply QR decomposition
         self._logger.debug(f"QR decompose a {T.nbytes / 2**20} MiB tensor.")
 
         subscripts = T_bonds + "->" + Q_bonds + "," + R_bonds
         options = {"handle": self._lib.handle, "device_id": self._lib.device_id}
         Q, R = tensor.decompose(
@@ -461,25 +320,25 @@
 
         # Update self.tensors
         self.tensors[pos] = Q
         self.canonical_form[pos] = form  # type: ignore
         self.tensors[next_pos] = result
         self.canonical_form[next_pos] = None
 
-    def vdot(self, other: MPS) -> complex:
+    def vdot(self, other: MPS) -> complex:  # type: ignore
         """Obtain the inner product of the two MPS: ``<self|other>``.
 
         It can be used to compute the squared norm of an MPS ``mps`` as
         ``mps.vdot(mps)``. The tensors within the MPS are not modified.
 
         Note:
             The state that is conjugated is ``self``.
 
         Args:
-            other: The other MPS to compare against.
+            other: The other MPS.
 
         Returns:
             The resulting complex number.
 
         Raises:
             RuntimeError: If number of tensors, dimensions or positions do not match.
             RuntimeError: If there are no tensors in the MPS.
@@ -816,14 +675,18 @@
         # Obtain the inner product
         value = self.vdot(mps_copy)
         assert np.isclose(value.imag, 0.0, atol=self._cfg._atol)
 
         self._logger.debug(f"Expectation value is {value.real}.")
         return value.real
 
+    def get_fidelity(self) -> float:
+        """Returns the current fidelity of the state."""
+        return self.fidelity
+
     def get_statevector(self) -> np.ndarray:
         """Returns the statevector with qubits in Increasing Lexicographic Order (ILO).
 
         Raises:
             ValueError: If there are no qubits left in the MPS.
         """
         if len(self) == 0:
```

## Comparing `pytket/extensions/cutensornet/mps/mps_gate.py` & `pytket/extensions/cutensornet/structured_state/mps_gate.py`

 * *Files 4% similar despite different names*

```diff
@@ -92,67 +92,65 @@
             ``self``, to allow for method chaining.
         """
         options = {"handle": self._lib.handle, "device_id": self._lib.device_id}
 
         l_pos = min(positions)
         r_pos = max(positions)
 
+        # Always canonicalise. Even in the case of exact simulation (no truncation)
+        # canonicalisation may reduce the bond dimension (thanks to reduced QR).
+        self.canonicalise(l_pos, r_pos)
+
         # Figure out the new dimension of the shared virtual bond
         new_dim = 2 * min(
             self.get_virtual_dimensions(l_pos)[0],
             self.get_virtual_dimensions(r_pos)[1],
         )
 
-        # Canonicalisation may be required if `new_dim` is larger than `chi`
-        # or if set by `truncation_fidelity`
-        if new_dim > self._cfg.chi or self._cfg.truncation_fidelity < 1:
-            # If truncation required, convert to canonical form before
-            # contracting. Avoids the need to apply gauge transformations
-            # to the larger tensor resulting from the contraction.
-            self.canonicalise(l_pos, r_pos)
-
-            # Since canonicalisation may change the dimension of the bonds,
-            # we need to recalculate the value of `new_dim`
-            new_dim = 2 * min(
-                self.get_virtual_dimensions(l_pos)[0],
-                self.get_virtual_dimensions(r_pos)[1],
-            )
-
         # Load the gate's unitary to the GPU memory
         gate_unitary = gate.get_unitary().astype(dtype=self._cfg._complex_t, copy=False)
         gate_tensor = cp.asarray(gate_unitary, dtype=self._cfg._complex_t)
 
         # Reshape into a rank-4 tensor
         gate_tensor = cp.reshape(gate_tensor, (2, 2, 2, 2))
 
         # Glossary of bond IDs
         # l -> physical bond of the left tensor in the MPS
         # r -> physical bond of the right tensor in the MPS
         # L -> left bond of the outcome of the gate
         # R -> right bond of the outcome of the gate
+        # S -> shared bond of the gate tensor's SVD
         # a,b,c -> the virtual bonds of the tensors
 
         if l_pos == positions[0]:
             gate_bonds = "LRlr"
         else:  # Implicit swap
             gate_bonds = "RLrl"
 
-        left_bonds = "abl"
-        right_bonds = "bcr"
-        result_bonds = "acLR"
+        # Apply SVD on the gate tensor to remove any zero singular values ASAP
+        svd_method = tensor.SVDMethod(
+            abs_cutoff=self._cfg.zero,
+            partition="U",  # Contract S directly into U
+        )
+        # Apply the SVD decomposition using the configuration defined above
+        U, S, V = tensor.decompose(
+            f"{gate_bonds}->SLl,SRr", gate_tensor, method=svd_method, options=options
+        )
+        assert S is None  # Due to "partition" option in SVDMethod
 
         # Contract
         self._logger.debug("Contracting the two-qubit gate with its site tensors...")
         T = cq.contract(
-            gate_bonds + "," + left_bonds + "," + right_bonds + "->" + result_bonds,
-            gate_tensor,
+            f"SLl,abl,SRr,bcr->acLR",
+            U,
             self.tensors[l_pos],
+            V,
             self.tensors[r_pos],
             options=options,
-            optimize={"path": [(0, 1), (0, 1)]},
+            optimize={"path": [(0, 1), (0, 1), (0, 1)]},
         )
         self._logger.debug(f"Intermediate tensor of size (MiB)={T.nbytes / 2**20}")
 
         # Get the template of the MPS tensors involved
         L = self.tensors[l_pos]
         R = self.tensors[r_pos]
 
@@ -183,15 +181,15 @@
             )
 
         else:
             # The user did not explicitly ask for truncation, but it is advantageous to
             # remove any singular values below ``self._cfg.zero``.
             self._logger.debug(f"Truncating singular values below={self._cfg.zero}.")
             if self._cfg.zero > self._cfg._atol / 1000:
-                self._logger.info(  # This was raised as a warning in ConfigMPS already
+                self._logger.info(  # This was raised as a warning in Config already
                     "Your chosen value_of_zero is relatively large. "
                     "Faithfulness of final fidelity estimate is not guaranteed."
                 )
 
             # NOTE: There is no guarantee of canonical form in this case. This is fine
             # since canonicalisation is just meant to detect the optimal singular values
             # to truncate, but if we find values that are essentially zero, we are safe
```

## Comparing `pytket/extensions/cutensornet/mps/mps_mpo.py` & `pytket/extensions/cutensornet/structured_state/mps_mpo.py`

 * *Files 3% similar despite different names*

```diff
@@ -25,19 +25,17 @@
 try:
     import cuquantum as cq  # type: ignore
     from cuquantum.cutensornet import tensor  # type: ignore
 except ImportError:
     warnings.warn("local settings failed to import cutensornet", ImportWarning)
 
 from pytket.circuit import Op, Qubit
+from .general import CuTensorNetHandle, Tensor, Config
 from .mps import (
-    CuTensorNetHandle,
-    DirectionMPS,
-    ConfigMPS,
-    Tensor,
+    DirMPS,
     MPS,
 )
 from .mps_gate import MPSxGate
 
 
 class MPSxMPO(MPS):
     """Implements a batched--gate contraction algorithm (DMRG-like) to calculate
@@ -45,15 +43,15 @@
     in: https://arxiv.org/abs/2207.05612.
     """
 
     def __init__(
         self,
         libhandle: CuTensorNetHandle,
         qubits: list[Qubit],
-        config: ConfigMPS,
+        config: Config,
     ):
         """Initialise an MPS on the computational state ``|0>``.
 
         Note:
             A ``libhandle`` should be created via a ``with CuTensorNet() as libhandle:``
             statement. The device where the MPS is stored will match the one specified
             by the library handle.
@@ -277,34 +275,34 @@
             raise RuntimeError(f"Position {position} is out of bounds.")
 
         if self._bond_ids[position]:
             return self._bond_ids[position][-1][-1]
         else:
             return self._new_bond_id()
 
-    def _get_column_bonds(self, position: int, direction: DirectionMPS) -> list[int]:
+    def _get_column_bonds(self, position: int, direction: DirMPS) -> list[int]:
         """Returns the unique identifier of all the left (right) virtual bonds of
         MPO tensors at ``position`` if ``direction`` is ``LEFT`` (``RIGHT``).
 
         Notes:
             It does not return the corresponding bonds of the MPS tensors.
 
         Raises:
             RuntimeError: If ``position`` is out of bounds.
-            ValueError: If ``direction`` is not a value in ``DirectionMPS``.
+            ValueError: If ``direction`` is not a value in ``DirMPS``.
         """
         if position < 0 or position >= len(self):
             raise RuntimeError(f"Position {position} is out of bounds.")
 
-        if direction == DirectionMPS.LEFT:
+        if direction == DirMPS.LEFT:
             index = 1  # By convention, left bond at index 1
-        elif direction == DirectionMPS.RIGHT:
+        elif direction == DirMPS.RIGHT:
             index = 2  # By convention, right bond at index 2
         else:
-            raise ValueError("Argument form must be a value in DirectionMPS.")
+            raise ValueError("Argument form must be a value in DirMPS.")
 
         return [b_ids[index] for b_ids in self._bond_ids[position]]
 
     def _flush(self) -> None:
         """Applies all batched operations within ``self._mpo`` to the MPS.
 
         The method applies variational optimisation of the MPS until it
@@ -312,28 +310,28 @@
         """
         self._logger.info("Applying variational optimisation.")
         self._logger.info(f"Fidelity before optimisation={self._aux_mps.fidelity}")
 
         l_cached_tensors: list[Tensor] = []
         r_cached_tensors: list[Tensor] = []
 
-        def update_sweep_cache(pos: int, direction: DirectionMPS) -> None:
+        def update_sweep_cache(pos: int, direction: DirMPS) -> None:
             """Given a position in the MPS and a sweeping direction (see
-            ``DirectionMPS``), calculate the tensor of the partial contraction
+            ``DirMPS``), calculate the tensor of the partial contraction
             of all MPS-MPO-vMPS* columns from ``pos`` towards ``direction``.
             Update the cache accordingly. Applies canonicalisation on the vMPS
             tensor before contracting.
             """
             self._logger.debug("Updating the sweep cache...")
 
             # Canonicalise the tensor at ``pos``
-            if direction == DirectionMPS.LEFT:
-                self._aux_mps.canonicalise_tensor(pos, form=DirectionMPS.RIGHT)
-            elif direction == DirectionMPS.RIGHT:
-                self._aux_mps.canonicalise_tensor(pos, form=DirectionMPS.LEFT)
+            if direction == DirMPS.LEFT:
+                self._aux_mps.canonicalise_tensor(pos, form=DirMPS.RIGHT)
+            elif direction == DirMPS.RIGHT:
+                self._aux_mps.canonicalise_tensor(pos, form=DirMPS.LEFT)
 
             # Glossary of bond IDs
             # p -> the physical bond of the MPS tensor
             # l,r -> the virtual bonds of the MPS tensor
             # L,R -> the virtual bonds of the variational MPS tensor
             # P -> the physical bond of the variational MPS tensor
             # MPO tensors will use ``self._bond_ids``
@@ -359,46 +357,46 @@
                 if i == len(self._mpo[pos]) - 1:
                     # The output bond of the last MPO tensor must connect to the
                     # physical bond of the corresponding ``self._aux_mps`` tensor
                     mpo_bonds[-1] = "P"
                 interleaved_rep.append(mpo_bonds)
 
             # Also contract the previous (cached) tensor during the sweep
-            if direction == DirectionMPS.LEFT:
+            if direction == DirMPS.LEFT:
                 if pos != len(self) - 1:  # Otherwise, there is nothing cached yet
                     interleaved_rep.append(r_cached_tensors[-1])
-                    r_cached_bonds = self._get_column_bonds(pos + 1, DirectionMPS.LEFT)
+                    r_cached_bonds = self._get_column_bonds(pos + 1, DirMPS.LEFT)
                     interleaved_rep.append(["r", "R"] + r_cached_bonds)
-            elif direction == DirectionMPS.RIGHT:
+            elif direction == DirMPS.RIGHT:
                 if pos != 0:  # Otherwise, there is nothing cached yet
                     interleaved_rep.append(l_cached_tensors[-1])
-                    l_cached_bonds = self._get_column_bonds(pos - 1, DirectionMPS.RIGHT)
+                    l_cached_bonds = self._get_column_bonds(pos - 1, DirMPS.RIGHT)
                     interleaved_rep.append(["l", "L"] + l_cached_bonds)
 
             # Figure out the ID of the bonds of the contracted tensor
-            if direction == DirectionMPS.LEFT:
+            if direction == DirMPS.LEFT:
                 # Take the left bond of each of the MPO tensors
-                result_bonds = self._get_column_bonds(pos, DirectionMPS.LEFT)
+                result_bonds = self._get_column_bonds(pos, DirMPS.LEFT)
                 # Take the left virtual bond of both of the MPS
                 interleaved_rep.append(["l", "L"] + result_bonds)
-            elif direction == DirectionMPS.RIGHT:
+            elif direction == DirMPS.RIGHT:
                 # Take the right bond of each of the MPO tensors
-                result_bonds = self._get_column_bonds(pos, DirectionMPS.RIGHT)
+                result_bonds = self._get_column_bonds(pos, DirMPS.RIGHT)
                 # Take the right virtual bond of both of the MPS
                 interleaved_rep.append(["r", "R"] + result_bonds)
 
             # Contract and store
             T = cq.contract(
                 *interleaved_rep,
                 options={"handle": self._lib.handle, "device_id": self._lib.device_id},
-                optimize={"samples": 1},
+                optimize={"samples": 0},
             )
-            if direction == DirectionMPS.LEFT:
+            if direction == DirMPS.LEFT:
                 r_cached_tensors.append(T)
-            elif direction == DirectionMPS.RIGHT:
+            elif direction == DirMPS.RIGHT:
                 l_cached_tensors.append(T)
 
             self._logger.debug("Completed update of the sweep cache.")
 
         def update_variational_tensor(
             pos: int, left_tensor: Optional[Tensor], right_tensor: Optional[Tensor]
         ) -> float:
@@ -432,31 +430,31 @@
                     # physical bond of the corresponding ``self._aux_mps`` tensor
                     mpo_bonds[-1] = "P"
                     result_bonds[-1] = "P"
                 interleaved_rep.append(mpo_bonds)
 
             if left_tensor is not None:
                 interleaved_rep.append(left_tensor)
-                left_tensor_bonds = self._get_column_bonds(pos - 1, DirectionMPS.RIGHT)
+                left_tensor_bonds = self._get_column_bonds(pos - 1, DirMPS.RIGHT)
                 interleaved_rep.append(["l", "L"] + left_tensor_bonds)
                 result_bonds[0] = "L"
             if right_tensor is not None:
                 interleaved_rep.append(right_tensor)
-                right_tensor_bonds = self._get_column_bonds(pos + 1, DirectionMPS.LEFT)
+                right_tensor_bonds = self._get_column_bonds(pos + 1, DirMPS.LEFT)
                 interleaved_rep.append(["r", "R"] + right_tensor_bonds)
                 result_bonds[1] = "R"
 
             # Append the bond IDs of the resulting tensor
             interleaved_rep.append(result_bonds)
 
             # Contract and store tensor
             F = cq.contract(
                 *interleaved_rep,
                 options={"handle": self._lib.handle, "device_id": self._lib.device_id},
-                optimize={"samples": 1},
+                optimize={"samples": 0},
             )
 
             # Get the fidelity
             optim_fidelity = complex(
                 cq.contract(
                     "LRP,LRP->",
                     F.conj(),
@@ -479,62 +477,62 @@
         ##################################
         # Variational sweeping algorithm #
         ##################################
 
         # Begin by doing a sweep towards the left that does not update
         # the variational tensors, but simply loads up the ``r_cached_tensors``
         for pos in reversed(range(1, len(self))):
-            update_sweep_cache(pos, direction=DirectionMPS.LEFT)
+            update_sweep_cache(pos, direction=DirMPS.LEFT)
 
         prev_fidelity = -1.0  # Dummy value
         sweep_fidelity = 0.0  # Dummy value
 
         # Repeat sweeps until the fidelity converges
-        sweep_direction = DirectionMPS.RIGHT
+        sweep_direction = DirMPS.RIGHT
         while not np.isclose(prev_fidelity, sweep_fidelity, atol=self._cfg.optim_delta):
             self._logger.info(f"Doing another optimisation sweep...")
             prev_fidelity = sweep_fidelity
 
-            if sweep_direction == DirectionMPS.RIGHT:
+            if sweep_direction == DirMPS.RIGHT:
                 sweep_fidelity = update_variational_tensor(
                     pos=0, left_tensor=None, right_tensor=r_cached_tensors.pop()
                 )
-                update_sweep_cache(pos=0, direction=DirectionMPS.RIGHT)
+                update_sweep_cache(pos=0, direction=DirMPS.RIGHT)
 
                 for pos in range(1, len(self) - 1):
                     sweep_fidelity = update_variational_tensor(
                         pos=pos,
                         left_tensor=l_cached_tensors[-1],
                         right_tensor=r_cached_tensors.pop(),
                     )
-                    update_sweep_cache(pos, direction=DirectionMPS.RIGHT)
+                    update_sweep_cache(pos, direction=DirMPS.RIGHT)
                 # The last variational tensor is not updated;
                 # it'll be the first in the next sweep
 
-                sweep_direction = DirectionMPS.LEFT
+                sweep_direction = DirMPS.LEFT
 
-            elif sweep_direction == DirectionMPS.LEFT:
+            elif sweep_direction == DirMPS.LEFT:
                 sweep_fidelity = update_variational_tensor(
                     pos=len(self) - 1,
                     left_tensor=l_cached_tensors.pop(),
                     right_tensor=None,
                 )
-                update_sweep_cache(pos=len(self) - 1, direction=DirectionMPS.LEFT)
+                update_sweep_cache(pos=len(self) - 1, direction=DirMPS.LEFT)
 
                 for pos in reversed(range(1, len(self) - 1)):
                     sweep_fidelity = update_variational_tensor(
                         pos=pos,
                         left_tensor=l_cached_tensors.pop(),
                         right_tensor=r_cached_tensors[-1],
                     )
-                    update_sweep_cache(pos, direction=DirectionMPS.LEFT)
+                    update_sweep_cache(pos, direction=DirMPS.LEFT)
                 # The last variational tensor is not updated;
                 # it'll be the first in the next sweep
 
-                sweep_direction = DirectionMPS.RIGHT
+                sweep_direction = DirMPS.RIGHT
 
             self._logger.info(
                 "Optimisation sweep completed. "
                 f"Current fidelity={self.fidelity*sweep_fidelity}"
             )
 
         # Clear out the MPO
```

## Comparing `pytket_cutensornet-0.5.4.dist-info/LICENSE` & `pytket_cutensornet-0.6.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `pytket_cutensornet-0.5.4.dist-info/METADATA` & `pytket_cutensornet-0.6.0.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: pytket-cutensornet
-Version: 0.5.4
+Version: 0.6.0
 Summary: Extension for pytket, providing access to the cuTensorNet Python API.
 Author: TKET development team
 Author-email: tket-support@cambridgequantum.com
 License: Apache 2
 Project-URL: Documentation, https://tket.quantinuum.com/extensions/pytket-cutensornet/index.html
 Project-URL: Source, https://github.com/CQCL/pytket-cutensornet
 Project-URL: Tracker, https://github.com/CQCL/pytket-cutensornet/issues
@@ -16,15 +16,15 @@
 Classifier: Operating System :: POSIX :: Linux
 Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: Science/Research
 Classifier: Topic :: Scientific/Engineering
 Requires-Python: >=3.10
 Description-Content-Type: text/markdown
 License-File: LICENSE
-Requires-Dist: pytket ~=1.24
+Requires-Dist: pytket ~=1.26
 
 # pytket-cutensornet
 
 [Pytket](https://tket.quantinuum.com/api-docs/index.html) is a python module for interfacing
 with tket, a quantum computing toolkit and optimising compiler developed by Quantinuum.
```

## Comparing `pytket_cutensornet-0.5.4.dist-info/RECORD` & `pytket_cutensornet-0.6.0.dist-info/RECORD`

 * *Files 14% similar despite different names*

```diff
@@ -1,18 +1,21 @@
 pytket/extensions/cutensornet/__init__.py,sha256=XuxFWXk5diNQecCUJwQt2evsZbDonno_k9eVeeI9k0E,1066
-pytket/extensions/cutensornet/_metadata.py,sha256=mnh8dLkMKCc6tcYFgU8cOlNiw_vf1fpC-EfGeQv4g_s,74
+pytket/extensions/cutensornet/_metadata.py,sha256=0UJXB2lTuJ-22e6Wr05hmRLuM0IXtGBFVFMn6m5I8AQ,74
 pytket/extensions/cutensornet/general.py,sha256=PnvHRWXtfJL6-G2au-o8kltV5lbAALcBB6R2G9h6zgw,1423
 pytket/extensions/cutensornet/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-pytket/extensions/cutensornet/tensor_network_convert.py,sha256=A-15975Mq9-sSPjJHQhS62guxDzTZzDt85Er4ASSR6A,28993
+pytket/extensions/cutensornet/tensor_network_convert.py,sha256=7zza89yzhay-8p_hTjF9xInryNFkBOkQsyzGE786l4E,29034
 pytket/extensions/cutensornet/utils.py,sha256=jbARtDYxf461tzdOv30SOIeazRVFpXCvlXWfnwxfK04,2630
 pytket/extensions/cutensornet/backends/__init__.py,sha256=jVQQ7tdyHyjZKiPyGbto4WtNVgEGSHLrVOqj7taja1I,705
 pytket/extensions/cutensornet/backends/cutensornet_backend.py,sha256=tCjlvIS6c40k_TZWlh73XfDUWNgT2v-zMVN8_k65ukw,10848
-pytket/extensions/cutensornet/mps/__init__.py,sha256=9sQA_NoH7QGmGKYw4LUhvoVe-8v_fWZmkYvWnHqqswM,1115
-pytket/extensions/cutensornet/mps/mps.py,sha256=sQ1yutwbrvCvMmnmxo6vbBq43Em7QbnoXTAgyop2PBg,43207
-pytket/extensions/cutensornet/mps/mps_gate.py,sha256=7dK10WhgCHf5SnrC_HXELsta-S5IjvT04jHMkPBxgS4,10401
-pytket/extensions/cutensornet/mps/mps_mpo.py,sha256=3SsVOnMUq-OPeAONrZ2rT9N5RQfpK72KrjZvOWGC5lQ,22948
-pytket/extensions/cutensornet/mps/simulation.py,sha256=o3hrxHU698KVXtK4RTE9HMGLfjGhGIta3gduK0dtrHM,9381
-pytket_cutensornet-0.5.4.dist-info/LICENSE,sha256=QwcOLU5TJoTeUhuIXzhdCEEDDvorGiC6-3YTOl4TecE,11356
-pytket_cutensornet-0.5.4.dist-info/METADATA,sha256=FnOrpScJec7MDmzPVn9FNJRHhn5UHP3YNfzeLrpkgFc,5102
-pytket_cutensornet-0.5.4.dist-info/WHEEL,sha256=oiQVh_5PnQM0E3gPdiz09WCNmwiHDMaGer_elqB3coM,92
-pytket_cutensornet-0.5.4.dist-info/top_level.txt,sha256=GsvCQQpJ7P8Vrx4ydtbjs36yufXiD59vSbbQFtFgcQ0,7
-pytket_cutensornet-0.5.4.dist-info/RECORD,,
+pytket/extensions/cutensornet/structured_state/__init__.py,sha256=XFuz_z8ay3fFiFiSqypvbETxKw0lB-LCEHgN_KtmS34,1212
+pytket/extensions/cutensornet/structured_state/general.py,sha256=r40cV3uy7sjVd7UGzomwXuy_H7hBUjVsQyOmeqKWHns,16125
+pytket/extensions/cutensornet/structured_state/mps.py,sha256=Yh8UavLmSpJ94dlO4Qf2yBaITRn8Apnd0dG8Xn-Exkk,36986
+pytket/extensions/cutensornet/structured_state/mps_gate.py,sha256=Sxivv-BAMautCeWYJYb7UjeIgUN3XHsMOeJBy779hzg,10290
+pytket/extensions/cutensornet/structured_state/mps_mpo.py,sha256=RZuikeVIGh7cDsTM-xdFemVWONa3_sQzqkozVLHAVwE,22744
+pytket/extensions/cutensornet/structured_state/simulation.py,sha256=DUJuSd1WM7NzgAqvxzIb05-mzcShNgPzuu90PM-MT1E,16196
+pytket/extensions/cutensornet/structured_state/ttn.py,sha256=wqlneWxk4verVNs--bJtFlke8FI_Zzn5H7jE4h1IIUU,33943
+pytket/extensions/cutensornet/structured_state/ttn_gate.py,sha256=oAftJGU-3cKwR7ob6TlrpJjWaEBxjx7zR4VbMqnroxs,32454
+pytket_cutensornet-0.6.0.dist-info/LICENSE,sha256=QwcOLU5TJoTeUhuIXzhdCEEDDvorGiC6-3YTOl4TecE,11356
+pytket_cutensornet-0.6.0.dist-info/METADATA,sha256=RhqZriWNLMZ0hr8oEEv-wDuVyggDchy6AruqGFjdI5E,5102
+pytket_cutensornet-0.6.0.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+pytket_cutensornet-0.6.0.dist-info/top_level.txt,sha256=GsvCQQpJ7P8Vrx4ydtbjs36yufXiD59vSbbQFtFgcQ0,7
+pytket_cutensornet-0.6.0.dist-info/RECORD,,
```

