# Comparing `tmp/vios-2.3.2-py3-none-any.whl.zip` & `tmp/vios-2.3.3-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,27 +1,27 @@
-Zip file size: 46675 bytes, number of entries: 25
--rw-rw-rw-  2.0 fat     2858 b- defN 24-Mar-19 11:19 quark/__main__.py
--rw-rw-rw-  2.0 fat    18356 b- defN 24-Apr-10 13:11 quark/proxy.py
--rw-rw-rw-  2.0 fat    18861 b- defN 24-Mar-21 10:46 quark/app/__init__.py
--rw-rw-rw-  2.0 fat     2575 b- defN 24-Mar-19 11:19 quark/app/_data.py
--rw-rw-rw-  2.0 fat    10205 b- defN 24-Mar-19 11:19 quark/app/demo.py
--rw-rw-rw-  2.0 fat     9043 b- defN 24-Mar-19 11:19 quark/app/task.py
--rw-rw-rw-  2.0 fat     5876 b- defN 24-Mar-19 11:19 quark/app/uapi.py
--rw-rw-rw-  2.0 fat     7914 b- defN 24-Mar-19 11:19 quark/driver/VirtualDevice.py
--rw-rw-rw-  2.0 fat      386 b- defN 24-Mar-19 11:19 quark/driver/__init__.py
--rw-rw-rw-  2.0 fat      217 b- defN 24-Mar-19 11:19 quark/driver/common/__init__.py
--rw-rw-rw-  2.0 fat     4478 b- defN 24-Mar-19 11:19 quark/driver/common/basedriver.py
--rw-rw-rw-  2.0 fat     4663 b- defN 24-Mar-19 11:19 quark/driver/common/quantity.py
--rw-rw-rw-  2.0 fat     5432 b- defN 24-Mar-19 11:19 quark/driver/common/visadriver.py
--rw-rw-rw-  2.0 fat     1188 b- defN 24-Mar-19 11:19 quark/envelope/__init__.py
--rw-rw-rw-  2.0 fat    15111 b- defN 24-Mar-19 11:19 quark/envelope/assembler.py
--rw-rw-rw-  2.0 fat     4322 b- defN 24-Mar-19 11:19 quark/envelope/calculator.py
--rw-rw-rw-  2.0 fat     1106 b- defN 24-Mar-19 11:19 quark/envelope/device.py
--rw-rw-rw-  2.0 fat     3758 b- defN 24-Mar-23 03:45 quark/envelope/processor.py
--rw-rw-rw-  2.0 fat     4306 b- defN 24-Apr-10 13:09 quark/envelope/router.py
--rw-rw-rw-  2.0 fat     2841 b- defN 24-Mar-21 12:16 quark/envelope/systemq.py
--rw-rw-rw-  2.0 fat     1085 b- defN 24-Apr-10 13:12 vios-2.3.2.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     1211 b- defN 24-Apr-10 13:12 vios-2.3.2.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 24-Apr-10 13:12 vios-2.3.2.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        6 b- defN 24-Apr-10 13:12 vios-2.3.2.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1995 b- defN 24-Apr-10 13:12 vios-2.3.2.dist-info/RECORD
-25 files, 127885 bytes uncompressed, 43499 bytes compressed:  66.0%
+Zip file size: 46797 bytes, number of entries: 25
+-rw-rw-rw-  2.0 fat     2858 b- defN 24-Mar-19 07:04 quark/__main__.py
+-rw-rw-rw-  2.0 fat    19127 b- defN 24-Apr-12 01:40 quark/proxy.py
+-rw-rw-rw-  2.0 fat    18861 b- defN 24-Mar-21 01:49 quark/app/__init__.py
+-rw-rw-rw-  2.0 fat     2575 b- defN 24-Apr-10 00:45 quark/app/_data.py
+-rw-rw-rw-  2.0 fat    10205 b- defN 24-Mar-19 07:04 quark/app/demo.py
+-rw-rw-rw-  2.0 fat     9043 b- defN 24-Mar-19 07:04 quark/app/task.py
+-rw-rw-rw-  2.0 fat     5876 b- defN 24-Mar-19 07:16 quark/app/uapi.py
+-rw-rw-rw-  2.0 fat     7914 b- defN 24-Mar-19 07:04 quark/driver/VirtualDevice.py
+-rw-rw-rw-  2.0 fat      386 b- defN 24-Mar-19 07:04 quark/driver/__init__.py
+-rw-rw-rw-  2.0 fat      217 b- defN 24-Mar-19 07:04 quark/driver/common/__init__.py
+-rw-rw-rw-  2.0 fat     4478 b- defN 24-Mar-19 07:04 quark/driver/common/basedriver.py
+-rw-rw-rw-  2.0 fat     4663 b- defN 24-Mar-19 07:04 quark/driver/common/quantity.py
+-rw-rw-rw-  2.0 fat     5432 b- defN 24-Mar-19 07:04 quark/driver/common/visadriver.py
+-rw-rw-rw-  2.0 fat     1188 b- defN 24-Mar-19 07:04 quark/envelope/__init__.py
+-rw-rw-rw-  2.0 fat    15111 b- defN 24-Mar-19 07:04 quark/envelope/assembler.py
+-rw-rw-rw-  2.0 fat     4322 b- defN 24-Mar-19 07:04 quark/envelope/calculator.py
+-rw-rw-rw-  2.0 fat     1106 b- defN 24-Mar-19 07:04 quark/envelope/device.py
+-rw-rw-rw-  2.0 fat     3758 b- defN 24-Mar-25 01:32 quark/envelope/processor.py
+-rw-rw-rw-  2.0 fat     4324 b- defN 24-Apr-11 01:52 quark/envelope/router.py
+-rw-rw-rw-  2.0 fat     2841 b- defN 24-Mar-25 01:32 quark/envelope/systemq.py
+-rw-rw-rw-  2.0 fat     1085 b- defN 24-Apr-12 03:17 vios-2.3.3.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     1215 b- defN 24-Apr-12 03:17 vios-2.3.3.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 24-Apr-12 03:17 vios-2.3.3.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        6 b- defN 24-Apr-12 03:17 vios-2.3.3.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1995 b- defN 24-Apr-12 03:17 vios-2.3.3.dist-info/RECORD
+25 files, 128678 bytes uncompressed, 43621 bytes compressed:  66.1%
```

## zipnote {}

```diff
@@ -54,23 +54,23 @@
 
 Filename: quark/envelope/router.py
 Comment: 
 
 Filename: quark/envelope/systemq.py
 Comment: 
 
-Filename: vios-2.3.2.dist-info/LICENSE
+Filename: vios-2.3.3.dist-info/LICENSE
 Comment: 
 
-Filename: vios-2.3.2.dist-info/METADATA
+Filename: vios-2.3.3.dist-info/METADATA
 Comment: 
 
-Filename: vios-2.3.2.dist-info/WHEEL
+Filename: vios-2.3.3.dist-info/WHEEL
 Comment: 
 
-Filename: vios-2.3.2.dist-info/top_level.txt
+Filename: vios-2.3.3.dist-info/top_level.txt
 Comment: 
 
-Filename: vios-2.3.2.dist-info/RECORD
+Filename: vios-2.3.3.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## quark/proxy.py

```diff
@@ -1,547 +1,552 @@
-"""!!! note "**用户输入输出**"
-
-- app: 用户函数或任务定义
-- driver: 设备驱动. **NOTE: 如发生改动, 需要重启server**
-    - 所有驱动继承自BaseDriver，类名统一为Driver，并要求实现open/close/read/write四个方法。样板见VirtualDevice
-    - 以设备或厂家为名新建文件夹(并于其内新建__init__.py文件)放于driver/common内，将厂家提供的底层库(若有)置于其内
-
-- envelope: 执行流程，见各模块说明. **NOTE: 如发生改动, 需要重启server**
-"""
-
-
-import asyncio
-import inspect
-import json
-import string
-import sys
-import time
-from collections import defaultdict
-from functools import cached_property
-from multiprocessing.shared_memory import SharedMemory
-from pathlib import Path
-from threading import Lock, Thread, current_thread
-
-import numpy as np
-from loguru import logger
-
-QUARK = Path.home()/'quark'
-
-try:
-    with open(QUARK/'startup.json', 'r') as f:
-        startup = json.loads(f.read())
-        SYSTEMQ = str(Path(startup['site']).resolve())
-        if SYSTEMQ.lower() not in sys.path:
-            sys.path.append(SYSTEMQ)
-except Exception as e:
-    logger.error(str(e))
-    startup = {}
-
-
-def setlog(prefix: str = ''):
-    logger.remove()
-    root = Path.home()/f"Desktop/home/log/proxy/{prefix}"
-    path = root/"{time:%Y-%m-%d}.log"
-    level = "INFO"
-    config = {'handlers': [{'sink': sys.stdout,
-                            'level': level},
-                           {'sink': path,
-                            'rotation': '00:00',
-                            'retention': '10 days',
-                            'encoding': 'utf-8',
-                            'level': level,
-                            'backtrace': False, }]}
-    # logger.add(path, rotation="20 MB")
-    logger.configure(**config)
-
-
-def debug(circuit: list = [(('Measure', 0), 'Q1001')], tid: int = 0):
-    from .app import get_config_by_tid
-    from .envelope import ccompile, initialize
-    initialize(get_config_by_tid(tid))
-    return ccompile(0, {}, circuit, signal='iq')
-
-
-TABLE = string.digits+string.ascii_uppercase
-
-
-def basen(number: int, base: int, table: str = TABLE):
-    mods = []
-    while True:
-        div, mod = divmod(number, base)
-        mods.append(mod)
-        if div == 0:
-            mods.reverse()
-            return ''.join([table[i] for i in mods])
-        number = div
-
-
-def baser(number: str, base: int, table: str = TABLE):
-    return sum([table.index(c)*base**i for i, c in enumerate(reversed(number))])
-
-
-def dumpv(value):
-    # print('ccccccccccccccccccccccc', value)
-    # if type(value).__name__ in ['Waveform', 'WaveVStack']:
-    #     sl = ShareableList([dump(value)])
-    #     result = ('ShareableList', sl.shm.name)
-    if isinstance(value, np.ndarray):
-        sm = SharedMemory(create=True, size=value.nbytes)
-        buf = np.ndarray(value.shape, dtype=value.dtype, buffer=sm.buf)
-        buf[:] = value[:]
-        result = sm, ('SharedMemory', sm.name, buf.shape, buf.dtype.str)
-        # sm.close()
-    else:
-        result = '', value
-    return result
-
-
-def loadv(value):
-    if isinstance(value, tuple) and value[0] == 'SharedMemory':
-        name, shape, dtype = value[1:]
-        shm = SharedMemory(name=name)
-        buf = np.ndarray(shape=shape, dtype=dtype, buffer=shm.buf)
-        return shm, buf
-    else:
-        return '', value
-
-
-try:
-    from IPython import get_ipython
-
-    shell = get_ipython().__class__.__name__
-    if shell == 'ZMQInteractiveShell':
-        from tqdm.notebook import tqdm  # jupyter notebook or qtconsole
-    else:
-        # ipython in terminal(TerminalInteractiveShell)
-        # None(Win)
-        # Nonetype(Mac)
-        from tqdm import tqdm
-except Exception as e:
-    # not installed or Probably IDLE
-    from tqdm import tqdm
-
-
-class Progress(tqdm):
-    """兼容JupyterProgressBar接口(from kernel)的实现
-    """
-    bar_format = '{desc} {percentage:3.0f}%|{bar}|{n_fmt}/{total_fmt} [{elapsed}<{remaining}, {rate_fmt}{postfix}]'
-
-    def __init__(self, desc='test', total=100, postfix='running', disable: bool = False):
-        super().__init__([], desc, total, ncols=None, colour='blue',
-                         bar_format=self.bar_format, position=0, postfix=postfix, disable=disable)
-
-    @property
-    def max(self):
-        return self.total
-
-    @max.setter
-    def max(self, value: int):
-        self.reset(value)
-
-    def goto(self, index: int):
-        self.n = index
-        self.refresh()
-
-    def finish(self, success: bool = True):
-        self.colour = 'green' if success else 'red'
-        # self.set_description_str(str(success))
-
-
-class Task(object):
-    """适用于大量任务连续提交(如量子云)
-    """
-
-    handles = {}
-    counter = defaultdict(lambda: 0)
-    server = None
-
-    def __init__(self, task: dict, timeout: float | None = None, plot: bool = False) -> None:
-        """实例化任务，用于跟踪进度、获取结果以及画图
-
-        Args:
-            task (dict): 任务描述，详见submit函数
-            timeout (float | None, optional): 阻塞任务最大时间. Defaults to None.
-            plot (bool, optional): 是否实时画图. 默认为False.
-        """
-        self.task = task
-        self.timeout = timeout
-        self.plot = plot
-
-        self.data: dict[str, np.ndarray] = {}  # 从server取回的数据
-        self.meta = {}  # 坐标轴等描述类信息
-        self.index = 0  # 当前已取回的数据数量
-        self.last = 0  # 上一次获取的数据量
-
-        self.thread = current_thread().name
-
-    @cached_property
-    def name(self):
-        return self.task['metainfo'].get('name', 'Unknown')
-
-    @cached_property
-    def ctx(self):
-        return self.step(-9, 'ctx')
-
-    def run(self):
-        """提交任务，如果有正在执行的任务则需等待
-        """
-        self.stime = time.time()  # start time
-        try:
-            circuit = self.task['taskinfo']['CIRQ']
-            if isinstance(circuit, list) and callable(circuit[0]):
-                circuit[0] = inspect.getsource(circuit[0])
-        except Exception as e:
-            logger.error(f'Failed to get circuit: {e}')
-        self.tid = self.server.submit(self.task)
-
-    def cancel(self):
-        """处理从server取回的数据
-        data (list[dict]): 一维数组, 其中每个元素均为dict, 即envelope.process函数返回值
-        """
-        self.server.cancel(self.tid)
-        # self.clear()
-
-    def result(self):
-        """从server取回数据
-        data (list[dict]): 一维数组, 其中每个元素均为dict, 即envelope.process函数返回值.
-        """
-        meta = True if not self.meta else False
-        res = self.server.fetch(self.tid, start=self.index, meta=meta)
-
-        if isinstance(res, str):
-            return self.data
-        elif isinstance(res, tuple):
-            if isinstance(res[0], str):
-                return self.data
-            data, self.meta = res
-        else:
-            data = res
-        self.last = self.index
-        self.index += len(data)
-        # data.clear()
-        self.process(data)
-
-        if callable(self.plot):
-            self.plot(self, not meta)
-            # self.plot(not meta)
-
-        return self.data
-
-    def status(self, key: str = 'runtime'):
-        if key == 'runtime':
-            return self.server.track(self.tid)
-        elif key == 'compile':
-            return self.server.apply('status', user='task')
-        else:
-            return 'supported arguments are: {rumtime, compile}'
-
-    def report(self):
-        return self.server.report(self.tid)
-
-    def step(self, index: int, stage: str = 'raw'):
-        """获取任务中某一步的详细信息
-
-        Args:
-            index (int): 步数.
-            stage (str, optional): 任务执行所经历的阶段. Defaults to 'raw'.
-
-        Examples: stage可取以下值
-            - ini: 编译生成的指令
-            - raw: 映射为硬件通道后的指令及收集好的相关参数
-            - ctx: 编译所用的上下文环境(ctx)
-            - debug: 由设备返回的原始数据
-            - trace: 每个指令执行所用时间
-
-        Returns:
-            _type_: _description_
-        """
-        if stage in ['ini', 'raw', 'ctx']:
-            return self.server.review(self.tid, index)[stage]
-        elif stage in ['debug', 'trace']:
-            return self.server.track(self.tid, index)[stage]
-
-    def process(self, data: list[dict]):
-        for dat in data:
-            for k, v in dat.items():
-                if k in self.data:
-                    self.data[k].append(v)
-                else:
-                    self.data[k] = [v]
-
-    def update(self):
-        try:
-            self.result()
-        except Exception as e:
-            logger.error(f'Failed to fetch result: {e}')
-
-        status = self.status()['status']
-
-        if status in ['Failed', 'Canceled']:
-            self.stop(self.tid, False)
-            return True
-        elif status in ['Running']:
-            self.progress.goto(self.index)
-            return False
-        elif status in ['Finished', 'Archived']:
-            self.progress.goto(self.progress.max)
-            if hasattr(self, 'app'):
-                self.app.save()
-            self.stop(self.tid)
-            self.result()
-            return True
-
-    def clear(self):
-        self.counter.clear()
-        for tid, handle in self.handles.items():
-            self.stop(tid)
-
-    def stop(self, tid: int, success: bool = True):
-        try:
-            self.progress.finish(success)
-            self.handles[tid].cancel()
-        except Exception as e:
-            pass
-
-    def bar(self, interval: float = 2.0, disable: bool = False):
-        """任务进度信息. 如果timeout非零, 则同步阻塞执行, 否则异步.
-        NOTE: 如果结果获取不到或者不全, 可能是save清空导致,可减小interval增加取数频率.
-
-        Args:
-            interval (float, optional): 进度刷新时间间隔, 不宜也不必过快. Defaults to 2.0.
-
-        Raises:
-            TimeoutError: 如果任务超过了认定的最大时间还未完则停止.
-                实际还在执行, 只是Task不再获取数据及进度.如不需要执行, 可cancel任务.
-        """
-        while True:
-            try:
-                status = self.status()['status']
-                if status in ['Pending']:
-                    time.sleep(interval)
-                    continue
-                elif status == 'Canceled':
-                    return 'Task canceled!'
-                else:
-                    self.progress = Progress(desc=self.name,
-                                             total=self.report()['size'],
-                                             postfix=self.thread, disable=disable)
-                    break
-            except Exception as e:
-                logger.error(
-                    f'Failed to get status: {e},{self.report()}')
-
-        if isinstance(self.timeout, float):
-            while True:
-                if self.timeout > 0 and (time.time() - self.stime > self.timeout):
-                    msg = f'Timeout: {self.timeout}'
-                    logger.warning(msg)
-                    raise TimeoutError(msg)
-                time.sleep(interval)
-                if self.update():
-                    break
-        else:
-            self.progress.clear()
-            self.refresh(interval)
-        self.progress.close()
-
-    def refresh(self, interval: float = 2.0):
-        self.progress.display()
-        if self.update():
-            self.progress.display()
-            return
-        self.handles[self.tid] = asyncio.get_running_loop(
-        ).call_later(interval, self.refresh, *(interval,))
-
-
-def transpile(task: dict):
-    quafuos = str(Path.home()/'Desktop/qusteed/0.1.4')
-    if quafuos not in sys.path:
-        print('adding quafuos', quafuos)
-        sys.path.append(quafuos)
-
-    circuit = task.get('circuit', '')
-    qasm = ''
-    if not isinstance(circuit, list):
-        from ._cloud import openqasm_to_qlisp
-        # if task.get('compile', True):
-        from qusteedAPIs import call_transpiler_api
-        qasm, final_qubit2cbit, compiled_circuit_information = call_transpiler_api(
-            input_circuit=circuit,
-            compile=task.get('compile', True),
-            backend=task.get('chip', ''))
-        # import compiler
-        # transpile
-        # else:
-        #     print('nononononoonoo compile')
-        #     qasm = circuit
-
-        circuit, qubits = openqasm_to_qlisp(qasm)
-
-    qlisp = ',\n'.join([str(op) for op in circuit])
-    logger.info(f"\n{'>'*36}qasm:\n{qasm}\n{'>'*36}qlisp:\n[{qlisp}]")
-
-    measure = []
-    for ops in circuit:
-        if isinstance(ops[0], tuple) and ops[0][0] == 'Measure':
-            measure.append((ops[0][1], ops[1]))
-    return qasm, [circuit], measure
-
-
-def update(backend: str, info: dict, token: str = ''):
-
-    quafuos = str(Path.home()/'Desktop/qusteed/0.1.4')
-    if quafuos not in sys.path:
-        print('adding quafuos', quafuos)
-        sys.path.append(quafuos)
-    with open(f'{backend}.json', 'w') as f:
-        f.write(json.dumps(info, indent=4))
-    from qusteedAPIs import call_local_backend_api
-    call_local_backend_api(backend=backend, chip_info_dict=info)
-    logger.warning(f'database of {backend} updated!')
-
-    try:
-        from ._cloud import update_chip_info_of_quafu
-        msg = update_chip_info_of_quafu(backend.lower(), info, token)
-        logger.warning(f'chip info of quafu[{backend.lower()}] updated!')
-    except Exception as e:
-        msg = f'Failed to update chip info of quafu, {e}'
-        logger.critical(msg)
-
-    return f'compiler database of {backend} updated!\r\n{msg}'
-
-
-class QuarkProxy(object):
-    """云客户端
-    """
-
-    def __init__(self) -> None:
-        from .app import login
-
-        self.server = login()
-        setlog()
-
-    def submit(self, task: dict, block: bool = False):
-        from .app import submit
-
-        # by server
-        # logger.info(f'task will be executed on local machine: {chip}!')
-        logger.warning(f'\n\n\n{"#"*80} task start to run ...\n')
-
-        try:
-            from home.ylfeng.cloud import get_bias_of_coupler
-            bias = get_bias_of_coupler()
-        except Exception as e:
-            bias = []
-            logger.error(f'Failed to get bias of coupler, {e}!')
-        circuit = [bias+c for c in task['taskinfo']['CIRQ']]
-        task['taskinfo']['CIRQ'] = circuit
-
-        qlisp = ',\n'.join([str(op) for op in circuit[0]])
-        qasm = task['metainfo']['coqis']['qasm']
-        logger.info(f"\n{'>'*36}qasm:\n{qasm}\n{'>'*36}qlisp:\n[{qlisp}]")
-
-        t: Task = submit(task, block=block)  # local machine
-        if block:
-            t.bar(0.2, disable=False)  # if block is True
-        eid = task['metainfo']['coqis']['eid']
-        logger.warning(f'task {t.tid}[{eid}] will be executed!')
-
-        return t.tid
-        # t.bar(0.1, True)
-
-        # ret = {}
-        # for kv in t.result()['count']:
-        #     base = tuple(kv[:-1])
-        #     ret[base] = ret.get(base, 0)+kv[-1]
-
-        # return ret, t.status()['status']
-
-    def cancel(self, tid: int):
-        return self.server.cancel(tid)
-
-    def status(self, tid: int = 0):
-        self.server.query('etc.cloud.online')
-
-    def result(self, tid: int, raw: bool = False):
-        """根据任务id获取结果
-
-        Args:
-            tid (int): 任务id
-
-        Returns:
-            dict: 数据及任务元信息
-        """
-        from .app import get_data_by_tid
-        try:
-            result = get_data_by_tid(tid, 'count')
-            return result if raw else self.process(result)
-        except Exception as e:
-            return f'No data found for {tid}!'
-
-    @classmethod
-    def process(cls, result: dict, dropout: bool = False):
-        def _delete_dict(ret: dict, num: int = 0):
-            while num > 0:
-                tmp = np.cumsum(list(ret.values()))
-                ran_num = np.random.randint(tmp[-1]+1)
-                ran_pos = np.searchsorted(tmp, ran_num)
-                ret[list(ret.keys())[ran_pos]] -= 1
-                if ret[list(ret.keys())[ran_pos]] == 0:
-                    ret.pop(list(ret.keys())[ran_pos], 0)
-                num -= 1
-
-        meta = result['meta']
-        coqis = meta.get('coqis', {})
-        status = 'Failed'
-        if meta['status'] in ['Finished', 'Archived']:
-            try:
-                # data: list[dict] = result['data']['count']
-                data: list[np.ndarray] = result['data']['count']
-                status = 'Finished'
-            except Exception as e:
-                logger.error(f'Failed to postprocess result: {e}')
-
-        dres, cdres = {}, {}
-        if status == 'Finished':
-            for dat in data:
-                # for k, v in dat.items():  # dat[()][0]
-                #     dres[k] = dres.get(k, 0)+v
-                for kv in dat:
-                    if kv[-1] < 0:
-                        continue
-                    base = tuple(kv[:-1]-1)  # from 1&2 to 0&1
-                    dres[base] = dres.get(base, 0)+int(kv[-1])
-
-            try:
-                if dropout:
-                    shots = meta['other']['shots'] * \
-                        len(meta['axis']['repeat']['repeat'])
-                    _delete_dict(dres, shots - (shots//1000)*1000)
-            except Exception as e:
-                logger.error(f'Failed to dropout: {e}')
-
-            try:
-                if meta['coqis']['correct']:
-                    from home.ylfeng.cloud import correct_readout
-                    cdres = correct_readout(dres, meta['other']['measure'])
-                else:
-                    cdres = {}
-            except Exception as e:
-                cdres = dres
-                logger.error(f'Failed to correct readout, {e}!')
-
-        ret = {'count': {''.join((str(i) for i in k)): v for k, v in dres.items()},
-               'corrected': {''.join((str(i) for i in k)): v for k, v in cdres.items()},
-               'transpiled': coqis.get('qasm', ''),
-               'qlisp': coqis.get('qlisp', ''),
-               'tid': meta['tid'],
-               'finished': meta['finished'],
-               'status': status
-               }
-        return ret
-
-    def sysinfo(self):
-        return self.server.sysinfo(False)
-
-    def snr(self, data):
-        return data
+"""!!! note "**用户输入输出**"
+
+- app: 用户函数或任务定义
+- driver: 设备驱动. **NOTE: 如发生改动, 需要重启server**
+    - 所有驱动继承自BaseDriver，类名统一为Driver，并要求实现open/close/read/write四个方法。样板见VirtualDevice
+    - 以设备或厂家为名新建文件夹(并于其内新建__init__.py文件)放于driver/common内，将厂家提供的底层库(若有)置于其内
+
+- envelope: 执行流程，见各模块说明. **NOTE: 如发生改动, 需要重启server**
+"""
+
+
+import asyncio
+import inspect
+import json
+import string
+import sys
+import time
+from collections import defaultdict
+from functools import cached_property
+from multiprocessing.shared_memory import SharedMemory
+from pathlib import Path
+from threading import Lock, Thread, current_thread
+
+import numpy as np
+from loguru import logger
+
+QUARK = Path.home()/'quark'
+
+try:
+    with open(QUARK/'startup.json', 'r') as f:
+        startup = json.loads(f.read())
+        SYSTEMQ = str(Path(startup['site']).resolve())
+        if SYSTEMQ.lower() not in sys.path:
+            sys.path.append(SYSTEMQ)
+except Exception as e:
+    logger.error(str(e))
+    startup = {}
+
+
+def setlog(prefix: str = ''):
+    logger.remove()
+    root = Path.home()/f"Desktop/home/log/proxy/{prefix}"
+    path = root/"{time:%Y-%m-%d}.log"
+    level = "INFO"
+    config = {'handlers': [{'sink': sys.stdout,
+                            'level': level},
+                           {'sink': path,
+                            'rotation': '00:00',
+                            'retention': '10 days',
+                            'encoding': 'utf-8',
+                            'level': level,
+                            'backtrace': False, }]}
+    # logger.add(path, rotation="20 MB")
+    logger.configure(**config)
+
+
+def debug(circuit: list = [(('Measure', 0), 'Q1001')], tid: int = 0):
+    from .app import get_config_by_tid
+    from .envelope import ccompile, initialize
+    initialize(get_config_by_tid(tid))
+    return ccompile(0, {}, circuit, signal='iq')
+
+
+TABLE = string.digits+string.ascii_uppercase
+
+
+def basen(number: int, base: int, table: str = TABLE):
+    mods = []
+    while True:
+        div, mod = divmod(number, base)
+        mods.append(mod)
+        if div == 0:
+            mods.reverse()
+            return ''.join([table[i] for i in mods])
+        number = div
+
+
+def baser(number: str, base: int, table: str = TABLE):
+    return sum([table.index(c)*base**i for i, c in enumerate(reversed(number))])
+
+
+def dumpv(value):
+    # print('ccccccccccccccccccccccc', value)
+    # if type(value).__name__ in ['Waveform', 'WaveVStack']:
+    #     sl = ShareableList([dump(value)])
+    #     result = ('ShareableList', sl.shm.name)
+    if isinstance(value, np.ndarray):
+        sm = SharedMemory(create=True, size=value.nbytes)
+        buf = np.ndarray(value.shape, dtype=value.dtype, buffer=sm.buf)
+        buf[:] = value[:]
+        result = sm, ('SharedMemory', sm.name, buf.shape, buf.dtype.str)
+        # sm.close()
+    else:
+        result = '', value
+    return result
+
+
+def loadv(value):
+    if isinstance(value, tuple) and value[0] == 'SharedMemory':
+        name, shape, dtype = value[1:]
+        shm = SharedMemory(name=name)
+        buf = np.ndarray(shape=shape, dtype=dtype, buffer=shm.buf)
+        return shm, buf
+    else:
+        return '', value
+
+
+try:
+    from IPython import get_ipython
+
+    shell = get_ipython().__class__.__name__
+    if shell == 'ZMQInteractiveShell':
+        from tqdm.notebook import tqdm  # jupyter notebook or qtconsole
+    else:
+        # ipython in terminal(TerminalInteractiveShell)
+        # None(Win)
+        # Nonetype(Mac)
+        from tqdm import tqdm
+except Exception as e:
+    # not installed or Probably IDLE
+    from tqdm import tqdm
+
+
+class Progress(tqdm):
+    """兼容JupyterProgressBar接口(from kernel)的实现
+    """
+    bar_format = '{desc} {percentage:3.0f}%|{bar}|{n_fmt}/{total_fmt} [{elapsed}<{remaining}, {rate_fmt}{postfix}]'
+
+    def __init__(self, desc='test', total=100, postfix='running', disable: bool = False):
+        super().__init__([], desc, total, ncols=None, colour='blue',
+                         bar_format=self.bar_format, position=0, postfix=postfix, disable=disable)
+
+    @property
+    def max(self):
+        return self.total
+
+    @max.setter
+    def max(self, value: int):
+        self.reset(value)
+
+    def goto(self, index: int):
+        self.n = index
+        self.refresh()
+
+    def finish(self, success: bool = True):
+        self.colour = 'green' if success else 'red'
+        # self.set_description_str(str(success))
+
+
+class Task(object):
+    """适用于大量任务连续提交(如量子云)
+    """
+
+    handles = {}
+    counter = defaultdict(lambda: 0)
+    server = None
+
+    def __init__(self, task: dict, timeout: float | None = None, plot: bool = False) -> None:
+        """实例化任务，用于跟踪进度、获取结果以及画图
+
+        Args:
+            task (dict): 任务描述，详见submit函数
+            timeout (float | None, optional): 阻塞任务最大时间. Defaults to None.
+            plot (bool, optional): 是否实时画图. 默认为False.
+        """
+        self.task = task
+        self.timeout = timeout
+        self.plot = plot
+
+        self.data: dict[str, np.ndarray] = {}  # 从server取回的数据
+        self.meta = {}  # 坐标轴等描述类信息
+        self.index = 0  # 当前已取回的数据数量
+        self.last = 0  # 上一次获取的数据量
+
+        self.thread = current_thread().name
+
+    @cached_property
+    def name(self):
+        return self.task['metainfo'].get('name', 'Unknown')
+
+    @cached_property
+    def ctx(self):
+        return self.step(-9, 'ctx')
+
+    def run(self):
+        """提交任务，如果有正在执行的任务则需等待
+        """
+        self.stime = time.time()  # start time
+        try:
+            circuit = self.task['taskinfo']['CIRQ']
+            if isinstance(circuit, list) and callable(circuit[0]):
+                circuit[0] = inspect.getsource(circuit[0])
+        except Exception as e:
+            logger.error(f'Failed to get circuit: {e}')
+        self.tid = self.server.submit(self.task)
+
+    def cancel(self):
+        """处理从server取回的数据
+        data (list[dict]): 一维数组, 其中每个元素均为dict, 即envelope.process函数返回值
+        """
+        self.server.cancel(self.tid)
+        # self.clear()
+
+    def result(self):
+        """从server取回数据
+        data (list[dict]): 一维数组, 其中每个元素均为dict, 即envelope.process函数返回值.
+        """
+        meta = True if not self.meta else False
+        res = self.server.fetch(self.tid, start=self.index, meta=meta)
+
+        if isinstance(res, str):
+            return self.data
+        elif isinstance(res, tuple):
+            if isinstance(res[0], str):
+                return self.data
+            data, self.meta = res
+        else:
+            data = res
+        self.last = self.index
+        self.index += len(data)
+        # data.clear()
+        self.process(data)
+
+        if callable(self.plot):
+            self.plot(self, not meta)
+            # self.plot(not meta)
+
+        return self.data
+
+    def status(self, key: str = 'runtime'):
+        if key == 'runtime':
+            return self.server.track(self.tid)
+        elif key == 'compile':
+            return self.server.apply('status', user='task')
+        else:
+            return 'supported arguments are: {rumtime, compile}'
+
+    def report(self):
+        return self.server.report(self.tid)
+
+    def step(self, index: int, stage: str = 'raw'):
+        """获取任务中某一步的详细信息
+
+        Args:
+            index (int): 步数.
+            stage (str, optional): 任务执行所经历的阶段. Defaults to 'raw'.
+
+        Examples: stage可取以下值
+            - ini: 编译生成的指令
+            - raw: 映射为硬件通道后的指令及收集好的相关参数
+            - ctx: 编译所用的上下文环境(ctx)
+            - debug: 由设备返回的原始数据
+            - trace: 每个指令执行所用时间
+
+        Returns:
+            _type_: _description_
+        """
+        if stage in ['ini', 'raw', 'ctx']:
+            return self.server.review(self.tid, index)[stage]
+        elif stage in ['debug', 'trace']:
+            return self.server.track(self.tid, index)[stage]
+
+    def process(self, data: list[dict]):
+        for dat in data:
+            for k, v in dat.items():
+                if k in self.data:
+                    self.data[k].append(v)
+                else:
+                    self.data[k] = [v]
+
+    def update(self):
+        try:
+            self.result()
+        except Exception as e:
+            logger.error(f'Failed to fetch result: {e}')
+
+        status = self.status()['status']
+
+        if status in ['Failed', 'Canceled']:
+            self.stop(self.tid, False)
+            return True
+        elif status in ['Running']:
+            self.progress.goto(self.index)
+            return False
+        elif status in ['Finished', 'Archived']:
+            self.progress.goto(self.progress.max)
+            if hasattr(self, 'app'):
+                self.app.save()
+            self.stop(self.tid)
+            self.result()
+            return True
+
+    def clear(self):
+        self.counter.clear()
+        for tid, handle in self.handles.items():
+            self.stop(tid)
+
+    def stop(self, tid: int, success: bool = True):
+        try:
+            self.progress.finish(success)
+            self.handles[tid].cancel()
+        except Exception as e:
+            pass
+
+    def bar(self, interval: float = 2.0, disable: bool = False):
+        """任务进度信息. 如果timeout非零, 则同步阻塞执行, 否则异步.
+        NOTE: 如果结果获取不到或者不全, 可能是save清空导致,可减小interval增加取数频率.
+
+        Args:
+            interval (float, optional): 进度刷新时间间隔, 不宜也不必过快. Defaults to 2.0.
+
+        Raises:
+            TimeoutError: 如果任务超过了认定的最大时间还未完则停止.
+                实际还在执行, 只是Task不再获取数据及进度.如不需要执行, 可cancel任务.
+        """
+        while True:
+            try:
+                status = self.status()['status']
+                if status in ['Pending']:
+                    time.sleep(interval)
+                    continue
+                elif status == 'Canceled':
+                    return 'Task canceled!'
+                else:
+                    self.progress = Progress(desc=self.name,
+                                             total=self.report()['size'],
+                                             postfix=self.thread, disable=disable)
+                    break
+            except Exception as e:
+                logger.error(
+                    f'Failed to get status: {e},{self.report()}')
+
+        if isinstance(self.timeout, float):
+            while True:
+                if self.timeout > 0 and (time.time() - self.stime > self.timeout):
+                    msg = f'Timeout: {self.timeout}'
+                    logger.warning(msg)
+                    raise TimeoutError(msg)
+                time.sleep(interval)
+                if self.update():
+                    break
+        else:
+            self.progress.clear()
+            self.refresh(interval)
+        self.progress.close()
+
+    def refresh(self, interval: float = 2.0):
+        self.progress.display()
+        if self.update():
+            self.progress.display()
+            return
+        self.handles[self.tid] = asyncio.get_running_loop(
+        ).call_later(interval, self.refresh, *(interval,))
+
+
+def transpile(task: dict):
+    quafuos = str(Path.home()/'Desktop/qusteed/0.1.4')
+    if quafuos not in sys.path:
+        print('adding quafuos', quafuos)
+        sys.path.append(quafuos)
+
+    circuit = task.get('circuit', '')
+    qasm = ''
+    if not isinstance(circuit, list):
+        from ._cloud import openqasm_to_qlisp
+        # if task.get('compile', True):
+        from qusteedAPIs import call_transpiler_api
+        qasm, final_qubit2cbit, compiled_circuit_information = call_transpiler_api(
+            input_circuit=circuit,
+            compile=task.get('compile', True),
+            backend=task.get('chip', ''))
+        # import compiler
+        # transpile
+        # else:
+        #     print('nononononoonoo compile')
+        #     qasm = circuit
+        if task['chip'] == 'Haituo':
+            QMAP = {i: f'Q{i+39}' for i in range(156)}
+        else:
+            QMAP = {i: f'Q{i+0}' for i in range(156)}
+
+        circuit, qubits = openqasm_to_qlisp(qasm, QMAP=QMAP)
+
+    qlisp = ',\n'.join([str(op) for op in circuit])
+    logger.info(f"\n{'>'*36}qasm:\n{qasm}\n{'>'*36}qlisp:\n[{qlisp}]")
+
+    measure = []
+    for ops in circuit:
+        if isinstance(ops[0], tuple) and ops[0][0] == 'Measure':
+            measure.append((ops[0][1], ops[1]))
+    return qasm, [circuit], measure
+
+
+def update(backend: str, info: dict, token: str = ''):
+
+    quafuos = str(Path.home()/'Desktop/qusteed/0.1.4')
+    if quafuos not in sys.path:
+        print('adding quafuos', quafuos)
+        sys.path.append(quafuos)
+    with open(f'{backend}.json', 'w') as f:
+        f.write(json.dumps(info, indent=4))
+    from qusteedAPIs import call_local_backend_api
+    call_local_backend_api(backend=backend, chip_info_dict=info)
+    logger.warning(f'database of {backend} updated!')
+
+    try:
+        from ._cloud import update_chip_info_of_quafu
+        msg = update_chip_info_of_quafu(backend.lower(), info, token)
+        logger.warning(f'chip info of quafu[{backend.lower()}] updated!')
+    except Exception as e:
+        msg = f'Failed to update chip info of quafu, {e}'
+        logger.critical(msg)
+
+    return f'compiler database of {backend} updated!\r\n{msg}'
+
+
+class QuarkProxy(object):
+    """云客户端
+    """
+
+    def __init__(self) -> None:
+        from .app import login
+
+        self.server = login()
+        setlog()
+
+    def submit(self, task: dict, block: bool = False):
+        from .app import submit
+
+        # by server
+        # logger.info(f'task will be executed on local machine: {chip}!')
+        logger.warning(f'\n\n\n{"#"*80} task start to run ...\n')
+
+        try:
+            from home.ylfeng.cloud import get_bias_of_coupler
+            bias = get_bias_of_coupler()
+        except Exception as e:
+            bias = []
+            logger.error(f'Failed to get bias of coupler, {e}!')
+        circuit = [bias+c for c in task['taskinfo']['CIRQ']]
+        task['taskinfo']['CIRQ'] = circuit
+
+        qlisp = ',\n'.join([str(op) for op in circuit[0]])
+        qasm = task['metainfo']['coqis']['qasm']
+        logger.info(f"\n{'>'*36}qasm:\n{qasm}\n{'>'*36}qlisp:\n[{qlisp}]")
+
+        t: Task = submit(task, block=block)  # local machine
+        if block:
+            t.bar(0.2, disable=False)  # if block is True
+        eid = task['metainfo']['coqis']['eid']
+        logger.warning(f'task {t.tid}[{eid}] will be executed!')
+
+        return t.tid
+        # t.bar(0.1, True)
+
+        # ret = {}
+        # for kv in t.result()['count']:
+        #     base = tuple(kv[:-1])
+        #     ret[base] = ret.get(base, 0)+kv[-1]
+
+        # return ret, t.status()['status']
+
+    def cancel(self, tid: int):
+        return self.server.cancel(tid)
+
+    def status(self, tid: int = 0):
+        self.server.query('etc.cloud.online')
+
+    def result(self, tid: int, raw: bool = False):
+        """根据任务id获取结果
+
+        Args:
+            tid (int): 任务id
+
+        Returns:
+            dict: 数据及任务元信息
+        """
+        from .app import get_data_by_tid
+        try:
+            result = get_data_by_tid(tid, 'count')
+            return result if raw else self.process(result)
+        except Exception as e:
+            return f'No data found for {tid}!'
+
+    @classmethod
+    def process(cls, result: dict, dropout: bool = False):
+        def _delete_dict(ret: dict, num: int = 0):
+            while num > 0:
+                tmp = np.cumsum(list(ret.values()))
+                ran_num = np.random.randint(tmp[-1]+1)
+                ran_pos = np.searchsorted(tmp, ran_num)
+                ret[list(ret.keys())[ran_pos]] -= 1
+                if ret[list(ret.keys())[ran_pos]] == 0:
+                    ret.pop(list(ret.keys())[ran_pos], 0)
+                num -= 1
+
+        meta = result['meta']
+        coqis = meta.get('coqis', {})
+        status = 'Failed'
+        if meta['status'] in ['Finished', 'Archived']:
+            try:
+                # data: list[dict] = result['data']['count']
+                data: list[np.ndarray] = result['data']['count']
+                status = 'Finished'
+            except Exception as e:
+                logger.error(f'Failed to postprocess result: {e}')
+
+        dres, cdres = {}, {}
+        if status == 'Finished':
+            for dat in data:
+                # for k, v in dat.items():  # dat[()][0]
+                #     dres[k] = dres.get(k, 0)+v
+                for kv in dat:
+                    if kv[-1] < 0:
+                        continue
+                    base = tuple(kv[:-1]-1)  # from 1&2 to 0&1
+                    dres[base] = dres.get(base, 0)+int(kv[-1])
+
+            try:
+                if dropout:
+                    shots = meta['other']['shots'] * \
+                        len(meta['axis']['repeat']['repeat'])
+                    _delete_dict(dres, shots - (shots//1000)*1000)
+            except Exception as e:
+                logger.error(f'Failed to dropout: {e}')
+
+            try:
+                if meta['coqis']['correct']:
+                    from home.ylfeng.cloud import correct_readout
+                    cdres = correct_readout(dres, meta['other']['measure'])
+                else:
+                    cdres = {}
+            except Exception as e:
+                cdres = dres
+                logger.error(f'Failed to correct readout, {e}!')
+
+        ret = {'count': {''.join((str(i) for i in k)): v for k, v in dres.items()},
+               'corrected': {''.join((str(i) for i in k)): v for k, v in cdres.items()},
+               'transpiled': coqis.get('qasm', ''),
+               'qlisp': coqis.get('qlisp', ''),
+               'tid': meta['tid'],
+               'error': meta.get('error', ''),
+               'status': status,
+               'finished': meta['finished'],
+               }
+        return ret
+
+    def sysinfo(self):
+        return self.server.sysinfo(False)
+
+    def snr(self, data):
+        return data
```

## quark/envelope/router.py

```diff
@@ -108,7 +108,9 @@
     try:
         resp = requests.post(url=f"http://124.70.54.59/qbackend/scq_result/",
                              data=post_data,
                              headers={'api_token': quafu['token']})
         logger.info(f'Back to quafu: {resp.text} {rshot}')
     except Exception as e:
         logger.error(f'Failed to post result: {e}')
+
+    return res
```

## Comparing `vios-2.3.2.dist-info/LICENSE` & `vios-2.3.3.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `vios-2.3.2.dist-info/METADATA` & `vios-2.3.3.dist-info/METADATA`

 * *Files 8% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: vios
-Version: 2.3.2
+Version: 2.3.3
 Summary: runtime requirements for systemq
 Author-email: YL Feng <fengyl@baqis.ac.cn>
 Project-URL: homepage, https://gitee.com
 Project-URL: bugs, https://gitee.com
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: Science/Research
@@ -24,16 +24,16 @@
 Requires-Dist: loguru
 Requires-Dist: cython
 Requires-Dist: gitpython
 Requires-Dist: waveforms
 Requires-Dist: pyvisa
 Requires-Dist: pyserial
 Provides-Extra: full
-Requires-Dist: quarkstudio[full] >=6.5.0 ; extra == 'full'
-Requires-Dist: waveforms-math >=1.0.0 ; extra == 'full'
+Requires-Dist: quarkstudio[full] (>=6.5.0) ; extra == 'full'
+Requires-Dist: waveforms-math (>=1.0.0) ; extra == 'full'
 
 ...
```

## Comparing `vios-2.3.2.dist-info/RECORD` & `vios-2.3.3.dist-info/RECORD`

 * *Files 12% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 quark/__main__.py,sha256=ky318p_RHmGRdMyzIL2meu-JOgqzRrH-hWfFvhceZGE,2858
-quark/proxy.py,sha256=OaEDhgn9FSVYRUKzfmGMbHenH3_qiwcHFTLvBiRHous,18356
+quark/proxy.py,sha256=TYqs3xJ4fBfwWCUWqmRQDyBtA0IHm0wEUev4HvXV0XA,19127
 quark/app/__init__.py,sha256=MjOh4mkjvwFzEEfPNv-dMOcoktAtYCBtl-P5_UA7MzQ,18861
 quark/app/_data.py,sha256=EGGTD2FrZ8vlbMh4jlmWhYk4fEG3FolGoWaQ26qxoss,2575
 quark/app/demo.py,sha256=eod5vSXKB0XI-Rr8UVKkNc9tOUfWCjI109Imd8bKmuo,10205
 quark/app/task.py,sha256=QEZuNia59sLEWa8pl2XIjItx2NismSTPZFnFt8-90HM,9043
 quark/app/uapi.py,sha256=itjEa89SUXozZqBGLH-3o4mKtRssNQODDj60knC-cGE,5876
 quark/driver/VirtualDevice.py,sha256=Cswl_ykFhIsocGV6Okh_YS1b48FeLm2fh1ruXqmNoyw,7914
 quark/driver/__init__.py,sha256=p1pVx1xTulBT8-qdp_zJ859tdIsA92XdvwrkqcVHL4s,386
@@ -12,14 +12,14 @@
 quark/driver/common/quantity.py,sha256=fV9DMmjys44efe7TTvzXmFdozqGdS2QUm23wtfLxeBE,4663
 quark/driver/common/visadriver.py,sha256=LRyYDBF0u9EYf6p47LeGGKhx9pHiq4pux_pzDakaICY,5432
 quark/envelope/__init__.py,sha256=5_cs0tZ7mV4GjOsY2isx8sUQu4u6Y3WN-9DUGG27SQM,1188
 quark/envelope/assembler.py,sha256=ENwX7FutJvpg6_Wcm42_Zx-ddq40JozuYqHPwJp09ZA,15111
 quark/envelope/calculator.py,sha256=0rZAA46sWh_X8wOBmpBvmljqCV53ID4VHPX1cE_abEc,4322
 quark/envelope/device.py,sha256=5E3oWZ84IYnQdzlmzltgPyayYz_au7p7UIbFVpJUa0Q,1106
 quark/envelope/processor.py,sha256=uMIwu83a4SDZVM3OE5_WrBya_4jxtdcXPd6pYa0osrk,3758
-quark/envelope/router.py,sha256=74afpudUyFnA2gjMbP2y0lu9ycy6R_8zPXIwkgyVIVA,4306
+quark/envelope/router.py,sha256=w3PiOCtc0YZZapwut2jWYf5vISTdZQWOGT_6bXTjCmI,4324
 quark/envelope/systemq.py,sha256=QAaHLv68C9UjMp9qHt9t-HJkOTpCkbHZTlNVOsAzIBc,2841
-vios-2.3.2.dist-info/LICENSE,sha256=B_BP5ebph3-SqRxXvo-6Bh7vzPL2nPY5qSFQfr7xM_s,1085
-vios-2.3.2.dist-info/METADATA,sha256=P03-hVcsHEkFE_dKVVwtPI4pCjZupUfku73k1CXmX3o,1211
-vios-2.3.2.dist-info/WHEEL,sha256=oiQVh_5PnQM0E3gPdiz09WCNmwiHDMaGer_elqB3coM,92
-vios-2.3.2.dist-info/top_level.txt,sha256=7SspgYXMW_50_NVkPj0EbFg4jFlGVsaIDfpqNsA1IMY,6
-vios-2.3.2.dist-info/RECORD,,
+vios-2.3.3.dist-info/LICENSE,sha256=B_BP5ebph3-SqRxXvo-6Bh7vzPL2nPY5qSFQfr7xM_s,1085
+vios-2.3.3.dist-info/METADATA,sha256=fkePnVnm9df9_oasYTVVGig8LqvujlXksLBIgq_Jf3Q,1215
+vios-2.3.3.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+vios-2.3.3.dist-info/top_level.txt,sha256=7SspgYXMW_50_NVkPj0EbFg4jFlGVsaIDfpqNsA1IMY,6
+vios-2.3.3.dist-info/RECORD,,
```

